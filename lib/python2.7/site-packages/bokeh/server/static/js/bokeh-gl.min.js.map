{"version":3,"sources":["tree/models/glyphs/webgl/base.js","tree/models/glyphs/webgl/gloo2.js","tree/models/glyphs/webgl/index.js","tree/models/glyphs/webgl/line.js","tree/models/glyphs/webgl/main.js","tree/models/glyphs/webgl/markers.js"],"names":["423","require","module","exports","color_1","BaseGLGlyph","gl","glyph","this","nvertices","size_changed","data_changed","visuals_changed","init","prototype","set_data_changed","n","set_visuals_changed","render","ctx","indices","mainglyph","dx","dy","sx","sy","trans","wx","wy","_a","renderer","map_to_screen","Math","min","max","abs","_b","_c","pixel_ratio","width","glcanvas","height","draw","GLYPH","VERT","FRAG","line_width","sqrt","fill_array_with_float","val","a","i","k","ref","Float32Array","fill_array_with_vec","m","j","l","ref1","visual_prop_is_singular","visual","propname","spec","value","attach_float","prog","vbo","att_name","name","doit","used","set_attribute","cache","set_size","set_data","attach_color","prefix","alphaname","alphas","colorname","colors","rgba","color2rgba","results","push","424","Buffer","GlooObject","IndexBuffer","Program","Texture2D","Texture3DLike","VertexBuffer","check_error","console","_pyfunc_add","b","Array","isArray","concat","_pyfunc_contains","length","_pyfunc_equals","constructor","Object","String","indexOf","e","Error","equals","iseq","akeys","keys","bkeys","sort","_pyfunc_instantiate","ob","args","window","global","undefined","nobind","bind","__init__","apply","_pyfunc_mult","_pymeth_repeat","call","t","res","_pyfunc_truthy","v","byteLength","getOwnPropertyNames","_pymeth_append","x","append","arguments","_pymeth_get","key","d","get","_pymeth_remove","remove","splice","count","repeat","result","pattern","valueOf","_pymeth_startswith","startswith","when","err","err_3","errors","msg","stub1_seq","stub2_itr","getError","NO_ERROR","_base_class","_class_name","_gl","handle","_create","err_2","create","UTYPEMAP","float","vec2","vec3","vec4","int","ivec2","ivec3","ivec4","bool","bvec2","bvec3","bvec4","mat2","mat3","mat4","sampler1D","sampler2D","sampler3D","ATYPEMAP","ATYPEINFO","createProgram","locations","_unset_variables","_validated","_samplers","_attributes","_known_invalid","delete","deleteProgram","activate","useProgram","deactivate","set_shaders","vert","frag","code","err_4","frag_handle","status","stub3_","tmp","type_","vert_handle","_linked","createShader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","_get_active_attributes_and_uniforms","detachShader","deleteShader","attributes","ca","container","cu","getActive","getLocation","info","regex","stub4_","stub5_seq","stub6_itr","uniforms","RegExp","ACTIVE_UNIFORMS","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","getActiveUniform","getUniformLocation","match","size","type","iter0","i0","set_texture","unit","log","_target","uniform1i","set_uniform","a_type","funcname","name_","chars","lstrip","slice","floor","stride","offset","gtype","is_vbo","stub7_","FALSE","_pre_draw","attr_handle","stub10_","stub11_seq","stub8_","stub9_seq","tex_handle","tex_target","vbo_handle","hasOwnProperty","activeTexture","TEXTURE0","bindTexture","bindBuffer","ARRAY_BUFFER","enableVertexAttribArray","disableVertexAttribArray","_validate","validateProgram","VALIDATE_STATUS","mode","selection","first","stub12_","_buffer_size","UNSIGNED_SHORT","drawElements","drawArrays","_usage","createBuffer","deleteBuffer","nbytes","bufferData","data","bufferSubData","_types","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","createTexture","_shape_format","deleteTexture","_get_alignment","alignment","stub13_seq","stub14_itr","set_wrapping","wrap_s","wrap_t","texParameterf","TEXTURE_WRAP_S","TEXTURE_WRAP_T","set_interpolation","mag","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","shape","format","stub15_","texImage2D","UNSIGNED_BYTE","u_shape","stub16_","stub17_","y","pixelStorei","UNPACK_ALIGNMENT","texSubImage2D","GLSL_SAMPLE_NEAREST","GLSL_SAMPLE_LINEAR","_get_tile_info","max_size","ncols","nrows","getParameter","MAX_TEXTURE_SIZE","ceil","sim_shape","stub18_","u_tiles","Type","col","elements_per_tile","row","stub19_","stub20_","tile","z","zeros","_pyfunc_all","425","tslib_1","__exportStar","426","DashAtlas","gloo2_1","base_1","_atlas","_index","_width","_height","tex","REPEAT","NEAREST","RGBA","get_atlas_data","period","join","make_pattern","len","C","Z","c","dash_end","dash_start","dash_type","index","p","q","r","ref2","val_at_index","LineGLGlyph","_super","__extends","_scale_aspect","index_buffer","vbo_position","vbo_tangents","vbo_segment","vbo_angles","vbo_texcoord","dash_atlas","mainGlyph","baked_offset","chunk","chunks","chunksize","mainGlGlyph","scale_length","these_indices","uint16_index","glglyph","isFinite","_baked_offset","_set_data","_set_visuals","_update_scale","cumsum","I_triangles","TRIANGLES","_bake","V_position","V_tangents","V_angles","V_texcoord","cap","color","dash_index","dash_pattern","dash_period","visuals","line","line_color","line_alpha","CAPS","line_cap","JOINS","line_join","line_dash","line_dash_offset","A","I","T","V_angles2","V_position2","V_tangents2","V_texcoord2","Vp","Vt","_x","_y","i1","ni","ref3","ref4","ref5","ref6","ref7","s","u","w","Float64Array","tangents","atan2","N","V_segment","V_segment2","pow","miter","round","bevel","","none",".",")","(","o","triangle in","<","triangle out",">","square","[","]","=","butt","|","FRAG_","427","428","MarkerGLGlyph","logging_1","CircleGLGlyph","replace","MARKERCODE","last_trans","vbo_x","vbo_y","vbo_s","vbo_a","vbo_linewidth","vbo_fg_color","vbo_bg_color","ua","_radius","sradius","POINTS","navigator","userAgent","logger","warn","xx","yy","_angle","_size","fill","SquareGLGlyph","AnnulusGLGlyph","DiamondGLGlyph","TriangleGLGlyph","InvertedTriangleGLGlyph","CrossGLGlyph","CircleCrossGLGlyph","SquareCrossGLGlyph","DiamondCrossGLGlyph","XGLGlyph","CircleXGLGlyph","SquareXGLGlyph","AsteriskGLGlyph"],"mappings":"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","file":"bokeh-gl.min.js","sourcesContent":["/*models/glyphs/webgl/base*/\nfunction _(require, module, exports) {\n    // This module implements the Base GL Glyph and some utilities\n    var color_1 = require(26    /* core/util/color */);\n    var BaseGLGlyph = function () {\n        function BaseGLGlyph(gl, glyph) {\n            this.gl = gl;\n            this.glyph = glyph;\n            this.nvertices = 0;\n            this.size_changed = false;\n            this.data_changed = false;\n            this.visuals_changed = false;\n            this.init();\n        }\n        BaseGLGlyph.prototype.set_data_changed = function (n) {\n            if (n !== this.nvertices) {\n                this.nvertices = n;\n                this.size_changed = true;\n            }\n            return this.data_changed = true;\n        };\n        BaseGLGlyph.prototype.set_visuals_changed = function () {\n            return this.visuals_changed = true;\n        };\n        BaseGLGlyph.prototype.render = function (ctx, indices, mainglyph) {\n            var dx, dy, sx, sy, trans, wx, wy;\n            // Get transform\n            wx = wy = 1;\n            // Weights to scale our vectors\n            _a = this.glyph.renderer.map_to_screen([\n                0 * wx,\n                1 * wx,\n                2 * wx\n            ], [\n                0 * wy,\n                1 * wy,\n                2 * wy\n            ]), dx = _a[0], dy = _a[1];\n            // Try again, but with weighs so we're looking at ~100 in screen coordinates\n            wx = 100 / Math.min(Math.max(Math.abs(dx[1] - dx[0]), 1e-12), 1000000000000);\n            wy = 100 / Math.min(Math.max(Math.abs(dy[1] - dy[0]), 1e-12), 1000000000000);\n            _b = this.glyph.renderer.map_to_screen([\n                0 * wx,\n                1 * wx,\n                2 * wx\n            ], [\n                0 * wy,\n                1 * wy,\n                2 * wy\n            ]), dx = _b[0], dy = _b[1];\n            // Test how linear it is\n            if (Math.abs(dx[1] - dx[0] - (dx[2] - dx[1])) > 0.000001 || Math.abs(dy[1] - dy[0] - (dy[2] - dy[1])) > 0.000001) {\n                return false;\n            }\n            _c = [\n                (dx[1] - dx[0]) / wx,\n                (dy[1] - dy[0]) / wy\n            ], sx = _c[0], sy = _c[1];\n            trans = {\n                pixel_ratio: ctx.pixel_ratio,\n                width: ctx.glcanvas.width,\n                height: ctx.glcanvas.height,\n                dx: dx[0] / sx,\n                dy: dy[0] / sy,\n                sx: sx,\n                sy: sy\n            };\n            this.draw(indices, mainglyph, trans);\n            return true;\n            // success\n            var _a, _b, _c;\n        };\n        return BaseGLGlyph;\n    }();\n    exports.BaseGLGlyph = BaseGLGlyph;\n    ;\n    BaseGLGlyph.prototype.GLYPH = '';\n    // name of the glyph that this gl-glyph applies to\n    BaseGLGlyph.prototype.VERT = '';\n    BaseGLGlyph.prototype.FRAG = '';\n    exports.line_width = function (width) {\n        // Increase small values to make it more similar to canvas\n        if (width < 2) {\n            width = Math.sqrt(width * 2);\n        }\n        return width;\n    };\n    exports.fill_array_with_float = function (n, val) {\n        var a, i, k, ref;\n        a = new Float32Array(n);\n        for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            a[i] = val;\n        }\n        return a;\n    };\n    exports.fill_array_with_vec = function (n, m, val) {\n        var a, i, j, k, l, ref, ref1;\n        a = new Float32Array(n * m);\n        for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n            for (j = l = 0, ref1 = m; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                a[i * m + j] = val[j];\n            }\n        }\n        return a;\n    };\n    exports.visual_prop_is_singular = function (visual, propname) {\n        // This touches the internals of the visual, so we limit use in this function\n        // See renderer.coffee:cache_select() for similar code\n        return visual[propname].spec.value !== void 0;\n    };\n    exports.attach_float = function (prog, vbo, att_name, n, visual, name) {\n        var a;\n        // Attach a float attribute to the program. Use singleton value if we can,\n        // otherwise use VBO to apply array.\n        if (!visual.doit) {\n            vbo.used = false;\n            return prog.set_attribute(att_name, 'float', [0]);\n        } else if (exports.visual_prop_is_singular(visual, name)) {\n            vbo.used = false;\n            return prog.set_attribute(att_name, 'float', visual[name].value());\n        } else {\n            vbo.used = true;\n            a = new Float32Array(visual.cache[name + '_array']);\n            vbo.set_size(n * 4);\n            vbo.set_data(0, a);\n            return prog.set_attribute(att_name, 'float', vbo);\n        }\n    };\n    exports.attach_color = function (prog, vbo, att_name, n, visual, prefix) {\n        var a, alphaname, alphas, colorname, colors, i, j, k, l, m, ref, ref1, rgba;\n        // Attach the color attribute to the program. If there's just one color,\n        // then use this single color for all vertices (no VBO). Otherwise we\n        // create an array and upload that to the VBO, which we attahce to the prog.\n        m = 4;\n        colorname = prefix + '_color';\n        alphaname = prefix + '_alpha';\n        if (!visual.doit) {\n            // Don't draw (draw transparent)\n            vbo.used = false;\n            return prog.set_attribute(att_name, 'vec4', [\n                0,\n                0,\n                0,\n                0\n            ]);\n        } else if (exports.visual_prop_is_singular(visual, colorname) && exports.visual_prop_is_singular(visual, alphaname)) {\n            // Nice and simple; both color and alpha are singular\n            vbo.used = false;\n            rgba = color_1.color2rgba(visual[colorname].value(), visual[alphaname].value());\n            return prog.set_attribute(att_name, 'vec4', rgba);\n        } else {\n            // Use vbo; we need an array for both the color and the alpha\n            vbo.used = true;\n            // Get array of colors\n            if (exports.visual_prop_is_singular(visual, colorname)) {\n                colors = function () {\n                    var k, ref, results;\n                    results = [];\n                    for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n                        results.push(visual[colorname].value());\n                    }\n                    return results;\n                }();\n            } else {\n                colors = visual.cache[colorname + '_array'];\n            }\n            // Get array of alphas\n            if (exports.visual_prop_is_singular(visual, alphaname)) {\n                alphas = exports.fill_array_with_float(n, visual[alphaname].value());\n            } else {\n                alphas = visual.cache[alphaname + '_array'];\n            }\n            // Create array of rgbs\n            a = new Float32Array(n * m);\n            for (i = k = 0, ref = n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {\n                rgba = color_1.color2rgba(colors[i], alphas[i]);\n                for (j = l = 0, ref1 = m; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {\n                    a[i * m + j] = rgba[j];\n                }\n            }\n            // Attach vbo\n            vbo.set_size(n * m * 4);\n            vbo.set_data(0, a);\n            return prog.set_attribute(att_name, 'vec4', vbo);\n        }\n    };    \n}","/*models/glyphs/webgl/gloo2*/\nfunction _(require, module, exports) {\n    /* Do not edit, autogenerated by flexx.pyscript */\n    var _pyfunc_add = function (a, b) {\n        if (Array.isArray(a) && Array.isArray(b)) {\n            return a.concat(b);\n        }\n        return a + b;\n    };\n    var _pyfunc_all = function (x) {\n        for (var i = 0; i < x.length; i++) {\n            if (!_pyfunc_truthy(x[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var _pyfunc_contains = function contains(a, b) {\n        if (b == null) {\n        } else if (Array.isArray(b)) {\n            for (var i = 0; i < b.length; i++) {\n                if (_pyfunc_equals(a, b[i]))\n                    return true;\n            }\n            return false;\n        } else if (b.constructor === Object) {\n            for (var k in b) {\n                if (a == k)\n                    return true;\n            }\n            return false;\n        } else if (b.constructor == String) {\n            return b.indexOf(a) >= 0;\n        }\n        var e = Error('Not a container: ' + b);\n        e.name = 'TypeError';\n        throw e;\n    };\n    var _pyfunc_equals = function equals(a, b) {\n        if (a == null || b == null) {\n        } else if (Array.isArray(a) && Array.isArray(b)) {\n            var i = 0, iseq = a.length == b.length;\n            while (iseq && i < a.length) {\n                iseq = equals(a[i], b[i]);\n                i += 1;\n            }\n            return iseq;\n        } else if (a.constructor === Object && b.constructor === Object) {\n            var akeys = Object.keys(a), bkeys = Object.keys(b);\n            akeys.sort();\n            bkeys.sort();\n            var i = 0, k, iseq = equals(akeys, bkeys);\n            while (iseq && i < akeys.length) {\n                k = akeys[i];\n                iseq = equals(a[k], b[k]);\n                i += 1;\n            }\n            return iseq;\n        }\n        return a == b;\n    };\n    var _pyfunc_instantiate = function (ob, args) {\n        if (typeof ob === 'undefined' || typeof window !== 'undefined' && window === ob || typeof global !== 'undefined' && global === ob) {\n            throw 'Class constructor is called as a function.';\n        }\n        for (var name in ob) {\n            if (Object[name] === undefined && typeof ob[name] === 'function' && !ob[name].nobind) {\n                ob[name] = ob[name].bind(ob);\n            }\n        }\n        if (ob.__init__) {\n            ob.__init__.apply(ob, args);\n        }\n    };\n    var _pyfunc_mult = function (a, b) {\n        if ((typeof a === 'number') + (typeof b === 'number') === 1) {\n            if (a.constructor === String)\n                return _pymeth_repeat.call(a, b);\n            if (b.constructor === String)\n                return _pymeth_repeat.call(b, a);\n            if (Array.isArray(b)) {\n                var t = a;\n                a = b;\n                b = t;\n            }\n            if (Array.isArray(a)) {\n                var res = [];\n                for (var i = 0; i < b; i++)\n                    res = res.concat(a);\n                return res;\n            }\n        }\n        return a * b;\n    };\n    var _pyfunc_range = function (start, end, step) {\n        var i, res = [];\n        var val = start;\n        var n = (end - start) / step;\n        for (i = 0; i < n; i++) {\n            res.push(val);\n            val += step;\n        }\n        return res;\n    };\n    var _pyfunc_truthy = function (v) {\n        if (v === null || typeof v !== 'object') {\n            return v;\n        } else if (v.length !== undefined) {\n            return v.length ? v : false;\n        } else if (v.byteLength !== undefined) {\n            return v.byteLength ? v : false;\n        } else if (v.constructor !== Object) {\n            return true;\n        } else {\n            return Object.getOwnPropertyNames(v).length ? v : false;\n        }\n    };\n    var _pymeth_append = function (x) {\n        if (!Array.isArray(this))\n            return this.append.apply(this, arguments);\n        this.push(x);\n    };\n    var _pymeth_get = function (key, d) {\n        if (this.constructor !== Object)\n            return this.get.apply(this, arguments);\n        if (this[key] !== undefined) {\n            return this[key];\n        } else if (d !== undefined) {\n            return d;\n        } else {\n            return null;\n        }\n    };\n    var _pymeth_keys = function () {\n        if (typeof this['keys'] === 'function')\n            return this.keys.apply(this, arguments);\n        return Object.keys(this);\n    };\n    var _pymeth_lstrip = function (chars) {\n        if (this.constructor !== String)\n            return this.lstrip.apply(this, arguments);\n        chars = chars === undefined ? ' \\t\\r\\n' : chars;\n        for (var i = 0; i < this.length; i++) {\n            if (chars.indexOf(this[i]) < 0)\n                return this.slice(i);\n        }\n        return '';\n    };\n    var _pymeth_remove = function (x) {\n        if (!Array.isArray(this))\n            return this.remove.apply(this, arguments);\n        for (var i = 0; i < this.length; i++) {\n            if (_pyfunc_equals(this[i], x)) {\n                this.splice(i, 1);\n                return;\n            }\n        }\n        var e = Error(x);\n        e.name = 'ValueError';\n        throw e;\n    };\n    var _pymeth_repeat = function (count) {\n        if (this.repeat)\n            return this.repeat(count);\n        if (count < 1)\n            return '';\n        var result = '', pattern = this.valueOf();\n        while (count > 1) {\n            if (count & 1)\n                result += pattern;\n            count >>= 1, pattern += pattern;\n        }\n        return result + pattern;\n    };\n    var _pymeth_startswith = function (x) {\n        if (this.constructor !== String)\n            return this.startswith.apply(this, arguments);\n        return this.indexOf(x) == 0;\n    };\n    var Buffer, GlooObject, IndexBuffer, Program, Texture2D, Texture3DLike, VertexBuffer, __version__, check_error, console;\n    // PyScript module for gloo2.js - lightweight object oriented GL.\n    {\n        console = window.console;\n    }\n    __version__ = '0.3';\n    check_error = function (gl, when) {\n        var e, err, err_3, errors, msg, stub1_seq, stub2_itr;\n        when = when === undefined ? 'periodic check' : when;\n        // Check this from time to time to detect GL errors.\n        //\n        //     Parameters\n        //     ----------\n        //     when : str\n        //         Shown in the exception to help the developer determine when\n        //         this check was done.\n        errors = [];\n        while (true) {\n            err = gl.getError();\n            if (_pyfunc_equals(err, gl.NO_ERROR) || _pyfunc_truthy(errors) && _pyfunc_equals(err, errors[errors.length - 1])) {\n                break;\n            }\n            _pymeth_append.call(errors, err);\n        }\n        if (errors.length) {\n            msg = '';\n            stub1_seq = errors;\n            if (typeof stub1_seq === 'object' && !Array.isArray(stub1_seq)) {\n                stub1_seq = Object.keys(stub1_seq);\n            }\n            for (stub2_itr = 0; stub2_itr < stub1_seq.length; stub2_itr += 1) {\n                e = stub1_seq[stub2_itr];\n                msg = _pyfunc_add(msg, e);\n            }\n            err_3 = new Error('RuntimeError:' + ('OpenGL got errors (' + when + '): ' + msg + ''));\n            err_3.name = 'RuntimeError';\n            throw err_3;\n        }\n        return null;\n    };\n    GlooObject = function () {\n        // Abstract base class for all Gloo classes.\n        _pyfunc_instantiate(this, arguments);\n    };\n    GlooObject.prototype._base_class = Object;\n    GlooObject.prototype._class_name = 'GlooObject';\n    GlooObject.prototype.__init__ = function (gl) {\n        // Init by passing the webgl context object.\n        this._gl = gl;\n        this.handle = null;\n        this._create();\n        if (!(this.handle !== null)) {\n            throw 'AssertionError: ' + 'this.handle !== null';\n        }\n        return null;\n    };\n    GlooObject.prototype._create = function () {\n        var err_2;\n        err_2 = new Error('NotImplementedError:' + '');\n        err_2.name = 'NotImplementedError';\n        throw err_2;\n        return null;\n    };\n    Program = function () {\n        // The program is the central component to connect gloo objects and shaders.\n        _pyfunc_instantiate(this, arguments);\n    };\n    Program.prototype = Object.create(GlooObject.prototype);\n    Program.prototype._base_class = GlooObject.prototype;\n    Program.prototype._class_name = 'Program';\n    Program.prototype.UTYPEMAP = {\n        'float': 'uniform1fv',\n        'vec2': 'uniform2fv',\n        'vec3': 'uniform3fv',\n        'vec4': 'uniform4fv',\n        'int': 'uniform1iv',\n        'ivec2': 'uniform2iv',\n        'ivec3': 'uniform3iv',\n        'ivec4': 'uniform4iv',\n        'bool': 'uniform1iv',\n        'bvec2': 'uniform2iv',\n        'bvec3': 'uniform3iv',\n        'bvec4': 'uniform4iv',\n        'mat2': 'uniformMatrix2fv',\n        'mat3': 'uniformMatrix3fv',\n        'mat4': 'uniformMatrix4fv',\n        'sampler1D': 'uniform1i',\n        'sampler2D': 'uniform1i',\n        'sampler3D': 'uniform1i'\n    };\n    Program.prototype.ATYPEMAP = {\n        'float': 'vertexAttrib1f',\n        'vec2': 'vertexAttrib2f',\n        'vec3': 'vertexAttrib3f',\n        'vec4': 'vertexAttrib4f'\n    };\n    Program.prototype.ATYPEINFO = {\n        'float': [\n            1,\n            5126\n        ],\n        'vec2': [\n            2,\n            5126\n        ],\n        'vec3': [\n            3,\n            5126\n        ],\n        'vec4': [\n            4,\n            5126\n        ]\n    };\n    Program.prototype._create = function () {\n        this.handle = this._gl.createProgram();\n        this.locations = {};\n        this._unset_variables = [];\n        this._validated = false;\n        this._samplers = {};\n        this._attributes = {};\n        this._known_invalid = [];\n        return null;\n    };\n    Program.prototype.delete = function () {\n        // Delete the program.\n        this._gl.deleteProgram(this.handle);\n        return null;\n    };\n    Program.prototype.activate = function () {\n        // Activate the program.\n        this._gl.useProgram(this.handle);\n        return null;\n    };\n    Program.prototype.deactivate = function () {\n        // Disable the program.\n        this._gl.useProgram(0);\n        return null;\n    };\n    Program.prototype.set_shaders = function (vert, frag) {\n        var code, err_3, err_4, errors, frag_handle, gl, handle, i, status, stub3_, tmp, type_, vert_handle;\n        // Set GLSL code for the vertex and fragment shader.\n        //\n        // This function takes care of setting the shading code and\n        // compiling+linking it into a working program object that is ready\n        // to use.\n        //\n        // Parameters\n        // ----------\n        // vert : str\n        //     GLSL code for the vertex shader.\n        // frag : str\n        //     GLSL code for the fragment shader.\n        gl = this._gl;\n        this._linked = false;\n        vert_handle = gl.createShader(gl.VERTEX_SHADER);\n        frag_handle = gl.createShader(gl.FRAGMENT_SHADER);\n        tmp = [\n            [\n                vert,\n                vert_handle,\n                'vertex'\n            ],\n            [\n                frag,\n                frag_handle,\n                'fragment'\n            ]\n        ];\n        for (i = 0; i < 2; i += 1) {\n            stub3_ = tmp[i];\n            code = stub3_[0];\n            handle = stub3_[1];\n            type_ = stub3_[2];\n            gl.shaderSource(handle, code);\n            gl.compileShader(handle);\n            status = gl.getShaderParameter(handle, gl.COMPILE_STATUS);\n            if (!_pyfunc_truthy(status)) {\n                errors = gl.getShaderInfoLog(handle);\n                err_4 = new Error('RuntimeError:' + _pyfunc_add('errors in ' + type_ + ' shader:\\n', errors));\n                err_4.name = 'RuntimeError';\n                throw err_4;\n            }\n        }\n        gl.attachShader(this.handle, vert_handle);\n        gl.attachShader(this.handle, frag_handle);\n        gl.linkProgram(this.handle);\n        if (!_pyfunc_truthy(gl.getProgramParameter(this.handle, gl.LINK_STATUS))) {\n            err_3 = new Error('RuntimeError:' + ('Program link error:\\n' + gl.getProgramInfoLog(this.handle)));\n            err_3.name = 'RuntimeError';\n            throw err_3;\n        }\n        this._unset_variables = this._get_active_attributes_and_uniforms();\n        gl.detachShader(this.handle, vert_handle);\n        gl.detachShader(this.handle, frag_handle);\n        gl.deleteShader(vert_handle);\n        gl.deleteShader(frag_handle);\n        this._known_invalid = [];\n        this._linked = true;\n        return null;\n    };\n    Program.prototype._get_active_attributes_and_uniforms = function () {\n        var attributes, ca, container, count, cu, getActive, getLocation, gl, i, info, j, m, name, regex, stub4_, stub5_seq, stub6_itr, uniforms, x;\n        // Retrieve active attributes and uniforms to be able to check that\n        // all uniforms/attributes are set by the user.\n        gl = this._gl;\n        this.locations = {};\n        regex = new window.RegExp('(\\\\w+)\\\\s*(\\\\[(\\\\d+)\\\\])\\\\s*');\n        cu = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);\n        ca = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);\n        attributes = [];\n        uniforms = [];\n        stub5_seq = [\n            [\n                attributes,\n                ca,\n                gl.getActiveAttrib,\n                gl.getAttribLocation\n            ],\n            [\n                uniforms,\n                cu,\n                gl.getActiveUniform,\n                gl.getUniformLocation\n            ]\n        ];\n        if (typeof stub5_seq === 'object' && !Array.isArray(stub5_seq)) {\n            stub5_seq = Object.keys(stub5_seq);\n        }\n        for (stub6_itr = 0; stub6_itr < stub5_seq.length; stub6_itr += 1) {\n            x = stub5_seq[stub6_itr];\n            stub4_ = x;\n            container = stub4_[0];\n            count = stub4_[1];\n            getActive = stub4_[2];\n            getLocation = stub4_[3];\n            for (i = 0; i < count; i += 1) {\n                info = getActive.call(gl, this.handle, i);\n                name = info.name;\n                m = name.match(regex);\n                if (_pyfunc_truthy(m)) {\n                    name = m[1];\n                    for (j = 0; j < info.size; j += 1) {\n                        _pymeth_append.call(container, [\n                            '' + name + '[' + j + ']',\n                            info.type\n                        ]);\n                    }\n                } else {\n                    _pymeth_append.call(container, [\n                        name,\n                        info.type\n                    ]);\n                }\n                this.locations[name] = getLocation.call(gl, this.handle, name);\n            }\n        }\n        return _pyfunc_add(function list_comprehenson() {\n            var res = [];\n            var v, iter0, i0;\n            iter0 = attributes;\n            if (typeof iter0 === 'object' && !Array.isArray(iter0)) {\n                iter0 = Object.keys(iter0);\n            }\n            for (i0 = 0; i0 < iter0.length; i0++) {\n                v = iter0[i0];\n                {\n                    res.push(v[0]);\n                }\n            }\n            return res;\n        }.apply(this), function list_comprehenson() {\n            var res = [];\n            var v, iter0, i0;\n            iter0 = uniforms;\n            if (typeof iter0 === 'object' && !Array.isArray(iter0)) {\n                iter0 = Object.keys(iter0);\n            }\n            for (i0 = 0; i0 < iter0.length; i0++) {\n                v = iter0[i0];\n                {\n                    res.push(v[0]);\n                }\n            }\n            return res;\n        }.apply(this));\n    };\n    Program.prototype.set_texture = function (name, value) {\n        var err_3, handle, unit;\n        // Set a texture sampler.\n        //\n        // A texture is a 2 dimensional grid of colors/intensities that\n        // can be applied to a face (or used for other means by providing\n        // a regular grid of data).\n        //\n        // Parameters\n        // ----------\n        // name : str\n        //     The name by which the texture is known in the GLSL code.\n        // value : Texture2D\n        //     The gloo Texture2D object to bind.\n        if (!_pyfunc_truthy(this._linked)) {\n            err_3 = new Error('RuntimeError:' + 'Cannot set uniform when program has no code');\n            err_3.name = 'RuntimeError';\n            throw err_3;\n        }\n        handle = _pymeth_get.call(this.locations, name, -1);\n        if (_pyfunc_truthy(handle < 0)) {\n            if (!_pyfunc_contains(name, this._known_invalid)) {\n                _pymeth_append.call(this._known_invalid, name);\n                console.log('Variable ' + name + ' is not an active texture');\n            }\n            return null;\n        }\n        if (_pyfunc_contains(name, this._unset_variables)) {\n            _pymeth_remove.call(this._unset_variables, name);\n        }\n        this.activate();\n        if (true) {\n            unit = _pymeth_keys.call(this._samplers).length;\n            if (_pyfunc_contains(name, this._samplers)) {\n                unit = this._samplers[name][this._samplers[name].length - 1];\n            }\n            this._samplers[name] = [\n                value._target,\n                value.handle,\n                unit\n            ];\n            this._gl.uniform1i(handle, unit);\n        }\n        return null;\n    };\n    Program.prototype.set_uniform = function (name, type_, value) {\n        var a_type, count, err_3, funcname, handle, j, name_;\n        // Set a uniform value.\n        //\n        // A uniform is a value that is global to both the vertex and\n        // fragment shader.\n        //\n        // Parameters\n        // ----------\n        // name : str\n        //     The name by which the uniform is known in the GLSL code.\n        // type_ : str\n        //     The type of the uniform, e.g. 'float', 'vec2', etc.\n        // value : list of scalars\n        //     The value for the uniform. Should be a list even for type float.\n        if (!_pyfunc_truthy(this._linked)) {\n            err_3 = new Error('RuntimeError:' + 'Cannot set uniform when program has no code');\n            err_3.name = 'RuntimeError';\n            throw err_3;\n        }\n        handle = _pymeth_get.call(this.locations, name, -1);\n        if (_pyfunc_truthy(handle < 0)) {\n            if (!_pyfunc_contains(name, this._known_invalid)) {\n                _pymeth_append.call(this._known_invalid, name);\n                console.log('Variable ' + name + ' is not an active uniform');\n            }\n            return null;\n        }\n        if (_pyfunc_contains(name, this._unset_variables)) {\n            _pymeth_remove.call(this._unset_variables, name);\n        }\n        count = 1;\n        if (!_pymeth_startswith.call(type_, 'mat')) {\n            a_type = _pymeth_get.call({\n                'int': 'float',\n                'bool': 'float'\n            }, type_, _pymeth_lstrip.call(type_, 'ib'));\n            count = Math.floor(value.length / this.ATYPEINFO[a_type][0]);\n        }\n        if (_pyfunc_truthy(count > 1)) {\n            for (j = 0; j < count; j += 1) {\n                if (_pyfunc_contains('' + name + '[' + j + ']', this._unset_variables)) {\n                    name_ = '' + name + '[' + j + ']';\n                    if (_pyfunc_contains(name_, this._unset_variables)) {\n                        _pymeth_remove.call(this._unset_variables, name_);\n                    }\n                }\n            }\n        }\n        funcname = this.UTYPEMAP[type_];\n        this.activate();\n        if (_pymeth_startswith.call(type_, 'mat')) {\n            this._gl[funcname](handle, false, value);\n        } else {\n            this._gl[funcname](handle, value);\n        }\n        return null;\n    };\n    Program.prototype.set_attribute = function (name, type_, value, stride, offset) {\n        var args, err_3, funcname, gtype, handle, is_vbo, size, stub7_;\n        stride = stride === undefined ? 0 : stride;\n        offset = offset === undefined ? 0 : offset;\n        // Set an attribute value.\n        //\n        // An attribute represents per-vertex data and can only be used\n        // in the vertex shader.\n        //\n        // Parameters\n        // ----------\n        // name : str\n        //     The name by which the attribute is known in the GLSL code.\n        // type_ : str\n        //     The type of the attribute, e.g. 'float', 'vec2', etc.\n        // value : VertexBuffer, array\n        //     If value is a VertexBuffer, it is used (with stride and offset)\n        //     for the vertex data. If value is an array, its used to set\n        //     the value of all vertices (similar to a uniform).\n        // stide : int, default 0\n        //     The stride to \"sample\" the vertex data inside the buffer. Unless\n        //     multiple vertex data are packed into a single buffer, this should\n        //     be zero.\n        // offset : int, default 0\n        //     The offset to \"sample\" the vertex data inside the buffer. Unless\n        //     multiple vertex data are packed into a single buffer, or only\n        //     a part of the data must be used, this should probably be zero.\n        if (!_pyfunc_truthy(this._linked)) {\n            err_3 = new Error('RuntimeError:' + 'Cannot set attribute when program has no code');\n            err_3.name = 'RuntimeError';\n            throw err_3;\n        }\n        is_vbo = value instanceof VertexBuffer;\n        handle = _pymeth_get.call(this.locations, name, -1);\n        if (_pyfunc_truthy(handle < 0)) {\n            if (!_pyfunc_contains(name, this._known_invalid)) {\n                _pymeth_append.call(this._known_invalid, name);\n                if (_pyfunc_truthy(is_vbo) && _pyfunc_truthy(offset > 0)) {\n                } else {\n                    console.log('Variable ' + name + ' is not an active attribute');\n                }\n            }\n            return null;\n        }\n        if (_pyfunc_contains(name, this._unset_variables)) {\n            _pymeth_remove.call(this._unset_variables, name);\n        }\n        this.activate();\n        if (!_pyfunc_truthy(is_vbo)) {\n            funcname = this.ATYPEMAP[type_];\n            this._attributes[name] = [\n                0,\n                handle,\n                funcname,\n                value\n            ];\n        } else {\n            stub7_ = this.ATYPEINFO[type_];\n            size = stub7_[0];\n            gtype = stub7_[1];\n            funcname = 'vertexAttribPointer';\n            args = [\n                size,\n                gtype,\n                this._gl.FALSE,\n                stride,\n                offset\n            ];\n            this._attributes[name] = [\n                value.handle,\n                handle,\n                funcname,\n                args\n            ];\n        }\n        return null;\n    };\n    Program.prototype._pre_draw = function () {\n        var args, attr_handle, funcname, stub10_, stub11_seq, stub8_, stub9_seq, tex_handle, tex_target, unit, vbo_handle, x;\n        // Prepare for drawing.\n        this.activate();\n        stub9_seq = this._samplers;\n        for (x in stub9_seq) {\n            if (!stub9_seq.hasOwnProperty(x)) {\n                continue;\n            }\n            x = stub9_seq[x];\n            stub8_ = x;\n            tex_target = stub8_[0];\n            tex_handle = stub8_[1];\n            unit = stub8_[2];\n            this._gl.activeTexture(_pyfunc_add(this._gl.TEXTURE0, unit));\n            this._gl.bindTexture(tex_target, tex_handle);\n        }\n        stub11_seq = this._attributes;\n        for (x in stub11_seq) {\n            if (!stub11_seq.hasOwnProperty(x)) {\n                continue;\n            }\n            x = stub11_seq[x];\n            stub10_ = x;\n            vbo_handle = stub10_[0];\n            attr_handle = stub10_[1];\n            funcname = stub10_[2];\n            args = stub10_[3];\n            if (_pyfunc_truthy(vbo_handle)) {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, vbo_handle);\n                this._gl.enableVertexAttribArray(attr_handle);\n                this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n            } else {\n                this._gl.bindBuffer(this._gl.ARRAY_BUFFER, null);\n                this._gl.disableVertexAttribArray(attr_handle);\n                this._gl[funcname].apply(this._gl, [].concat([attr_handle], args));\n            }\n        }\n        if (!_pyfunc_truthy(this._validated)) {\n            this._validated = true;\n            this._validate();\n        }\n        return null;\n    };\n    Program.prototype._validate = function () {\n        var err_3;\n        if (this._unset_variables.length) {\n            console.log('Program has unset variables: ' + this._unset_variables + '');\n        }\n        this._gl.validateProgram(this.handle);\n        if (!_pyfunc_truthy(this._gl.getProgramParameter(this.handle, this._gl.VALIDATE_STATUS))) {\n            console.log(this._gl.getProgramInfoLog(this.handle));\n            err_3 = new Error('RuntimeError:' + 'Program validation error');\n            err_3.name = 'RuntimeError';\n            throw err_3;\n        }\n        return null;\n    };\n    Program.prototype.draw = function (mode, selection) {\n        var count, err_3, first, gtype, stub12_;\n        // Draw the current visualization defined by the program.\n        //\n        // Parameters\n        // ----------\n        // mode : GL enum\n        //     Can be POINTS, LINES, LINE_LOOP, LINE_STRIP, LINE_FAN, TRIANGLES\n        // selection : 2-element tuple or IndexBuffer\n        //     The selection to draw, specified either as (first, count) or an\n        //     IndexBuffer object.\n        if (!_pyfunc_truthy(this._linked)) {\n            err_3 = new Error('RuntimeError:' + 'Cannot draw program if code has not been set');\n            err_3.name = 'RuntimeError';\n            throw err_3;\n        }\n        check_error(this._gl, 'before draw');\n        if (_pyfunc_truthy(selection instanceof IndexBuffer)) {\n            this._pre_draw();\n            selection.activate();\n            count = selection._buffer_size / 2;\n            gtype = this._gl.UNSIGNED_SHORT;\n            this._gl.drawElements(mode, count, gtype, 0);\n            selection.deactivate();\n        } else {\n            stub12_ = selection;\n            first = stub12_[0];\n            count = stub12_[1];\n            if (_pyfunc_truthy(count)) {\n                this._pre_draw();\n                this._gl.drawArrays(mode, first, count);\n            }\n        }\n        check_error(this._gl, 'after draw');\n        return null;\n    };\n    Buffer = function () {\n        // Base buffer class for vertex data or index data.\n        _pyfunc_instantiate(this, arguments);\n    };\n    Buffer.prototype = Object.create(GlooObject.prototype);\n    Buffer.prototype._base_class = GlooObject.prototype;\n    Buffer.prototype._class_name = 'Buffer';\n    Buffer.prototype._target = null;\n    Buffer.prototype._usage = 35048;\n    Buffer.prototype._create = function () {\n        this.handle = this._gl.createBuffer();\n        this._buffer_size = 0;\n        return null;\n    };\n    Buffer.prototype.delete = function () {\n        // Delete the buffer.\n        this._gl.deleteBuffer(this.handle);\n        return null;\n    };\n    Buffer.prototype.activate = function () {\n        // Activete the buffer.\n        this._gl.bindBuffer(this._target, this.handle);\n        return null;\n    };\n    Buffer.prototype.deactivate = function () {\n        // Disable the buffer.\n        this._gl.bindBuffer(this._target, null);\n        return null;\n    };\n    Buffer.prototype.set_size = function (nbytes) {\n        // Set the size of the buffer in bytes.\n        //\n        // Parameters\n        // ----------\n        // nbytes : int\n        //     The number of bytes that the buffer needs to hold.\n        if (!_pyfunc_equals(nbytes, this._buffer_size)) {\n            this.activate();\n            this._gl.bufferData(this._target, nbytes, this._usage);\n            this._buffer_size = nbytes;\n        }\n        return null;\n    };\n    Buffer.prototype.set_data = function (offset, data) {\n        // Set the buffer data.\n        //\n        // Parameters\n        // ----------\n        // offset : int\n        //     The offset in bytes for the new data.\n        // data : typed array\n        //     The data to upload.\n        this.activate();\n        this._gl.bufferSubData(this._target, offset, data);\n        return null;\n    };\n    VertexBuffer = function () {\n        // A buffer for vertex data.\n        _pyfunc_instantiate(this, arguments);\n    };\n    VertexBuffer.prototype = Object.create(Buffer.prototype);\n    VertexBuffer.prototype._base_class = Buffer.prototype;\n    VertexBuffer.prototype._class_name = 'VertexBuffer';\n    VertexBuffer.prototype._target = 34962;\n    IndexBuffer = function () {\n        // A buffer for index data.\n        _pyfunc_instantiate(this, arguments);\n    };\n    IndexBuffer.prototype = Object.create(Buffer.prototype);\n    IndexBuffer.prototype._base_class = Buffer.prototype;\n    IndexBuffer.prototype._class_name = 'IndexBuffer';\n    IndexBuffer.prototype._target = 34963;\n    Texture2D = function () {\n        // A 2 dimensional regular grid.\n        _pyfunc_instantiate(this, arguments);\n    };\n    Texture2D.prototype = Object.create(GlooObject.prototype);\n    Texture2D.prototype._base_class = GlooObject.prototype;\n    Texture2D.prototype._class_name = 'Texture2D';\n    Texture2D.prototype._target = 3553;\n    Texture2D.prototype._types = {\n        'Int8Array': 5120,\n        'Uint8Array': 5121,\n        'Int16Array': 5122,\n        'Uint16Array': 5123,\n        'Int32Array': 5124,\n        'Uint32Array': 5125,\n        'Float32Array': 5126\n    };\n    Texture2D.prototype._create = function () {\n        this.handle = this._gl.createTexture();\n        this._shape_format = null;\n        return null;\n    };\n    Texture2D.prototype.delete = function () {\n        // Delete the texture.\n        this._gl.deleteTexture(this.handle);\n        return null;\n    };\n    Texture2D.prototype.activate = function () {\n        // Activate the texture.\n        this._gl.bindTexture(this._target, this.handle);\n        return null;\n    };\n    Texture2D.prototype.deactivate = function () {\n        // Disable the texture.\n        this._gl.bindTexture(this._target, 0);\n        return null;\n    };\n    Texture2D.prototype._get_alignment = function (width) {\n        var alignment, alignments, stub13_seq, stub14_itr;\n        // Determines a textures byte alignment. If the width isn't a\n        //         power of 2 we need to adjust the byte alignment of the image.\n        //         The image height is unimportant.\n        //\n        //         www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads\n        alignments = [\n            4,\n            8,\n            2,\n            1\n        ];\n        stub13_seq = alignments;\n        if (typeof stub13_seq === 'object' && !Array.isArray(stub13_seq)) {\n            stub13_seq = Object.keys(stub13_seq);\n        }\n        for (stub14_itr = 0; stub14_itr < stub13_seq.length; stub14_itr += 1) {\n            alignment = stub13_seq[stub14_itr];\n            if (_pyfunc_equals(width % alignment, 0)) {\n                return alignment;\n            }\n        }\n        return null;\n    };\n    Texture2D.prototype.set_wrapping = function (wrap_s, wrap_t) {\n        // Set the texture wrapping mode.\n        //\n        // Parameters\n        // ----------\n        // wrap_s : GL enum\n        //     The mode to wrap the x dimension. Valid values are REPEAT\n        //     CLAMP_TO_EDGE MIRRORED_REPEAT\n        // wrap_t : GL enum\n        //     The mode to wrap the y dimension. Same options as for wrap_s.\n        this.activate();\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_S, wrap_s);\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_WRAP_T, wrap_t);\n        return null;\n    };\n    Texture2D.prototype.set_interpolation = function (min, mag) {\n        // Set the texture interpolation mode\n        //\n        // Parameters\n        // ----------\n        // min : GL enum\n        //     The interpolation mode when minifying (i.e. zoomed out). Valid\n        //     values are LINEAR and NEAREST.\n        // max : GL enum\n        //     The interpolation mode when magnifying (i.e. zoomed in). Valid\n        //     values are LINEAR, NEAREST, NEAREST_MIPMAP_NEAREST,\n        //     LINEAR_MIPMAP_NEAREST, NEAREST_MIPMAP_LINEAR, LINEAR_MIPMAP_LINEAR.\n        this.activate();\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_MIN_FILTER, min);\n        this._gl.texParameterf(this._target, this._gl.TEXTURE_MAG_FILTER, mag);\n        return null;\n    };\n    Texture2D.prototype.set_size = function (shape, format) {\n        var height, stub15_, width;\n        // Set the size of the 2D texture.\n        //\n        // Parameters\n        // ----------\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // format : GL enum\n        //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n        //     RGB, and RGBA.\n        stub15_ = shape;\n        height = stub15_[0];\n        width = stub15_[1];\n        if (!_pyfunc_equals([\n                height,\n                width,\n                format\n            ], this._shape_format)) {\n            this._shape_format = [\n                height,\n                width,\n                format\n            ];\n            this.activate();\n            this._gl.texImage2D(this._target, 0, format, width, height, 0, format, this._gl.UNSIGNED_BYTE, null);\n        }\n        this.u_shape = [\n            height,\n            width\n        ];\n        return null;\n    };\n    Texture2D.prototype.set_data = function (offset, shape, data) {\n        var _, alignment, err_3, format, gtype, height, stub16_, stub17_, width, x, y;\n        // Set the 2D texture data.\n        //\n        // Parameters\n        // ----------\n        // offset : tuple of ints\n        //     Offset in pixels for each dimension.\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // data : typed array\n        //     The actual pixel data. Can be of any type, but on the GPU the\n        //     dat is stored in 8 bit precision.\n        if (_pyfunc_equals(shape.length, 2)) {\n            shape = [\n                shape[0],\n                shape[1],\n                1\n            ];\n        }\n        this.activate();\n        format = this._shape_format[2];\n        stub16_ = shape;\n        height = stub16_[0];\n        width = stub16_[1];\n        _ = stub16_[2];\n        stub17_ = offset;\n        y = stub17_[0];\n        x = stub17_[1];\n        gtype = _pymeth_get.call(this._types, data.constructor.name, null);\n        if (gtype === null) {\n            err_3 = new Error('ValueError:' + ('Type ' + data.constructor.name + ' not allowed for texture'));\n            err_3.name = 'ValueError';\n            throw err_3;\n        }\n        alignment = this._get_alignment(_pyfunc_mult(shape[shape.length - 2], shape[shape.length - 1]));\n        if (!_pyfunc_equals(alignment, 4)) {\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, alignment);\n        }\n        this._gl.texSubImage2D(this._target, 0, x, y, width, height, format, gtype, data);\n        if (!_pyfunc_equals(alignment, 4)) {\n            this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 4);\n        }\n        return null;\n    };\n    Texture3DLike = function () {\n        // A 2D texture with support to simulate a 3D texture.\n        //\n        // To use this class, use set_size() and set_data() as if it was a 3D\n        // texture. Add the GLSL_SAMPLE_NEAREST or GLSL_SAMPLE_LINEAR to the\n        // shader to add the sample3D() function that can be used instead of\n        // texture2D(). This function needs ``shape`` and ``tiles`` arguments\n        // which can be set via uniforms, using the ``u_shape`` and ``u_tiles``\n        // attributes of this object.\n        _pyfunc_instantiate(this, arguments);\n    };\n    Texture3DLike.prototype = Object.create(Texture2D.prototype);\n    Texture3DLike.prototype._base_class = Texture2D.prototype;\n    Texture3DLike.prototype._class_name = 'Texture3DLike';\n    Texture3DLike.prototype.GLSL_SAMPLE_NEAREST = '\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don\\'t let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float zindex = floor(texcoord.z * shape.z);\\n\\n            // Do a lookup in the 2D texture\\n            float u = (mod(zindex, ncols) + texcoord.x) / ncols;\\n            float v = (floor(zindex / ncols) + texcoord.y) / nrows;\\n\\n            return texture2D(tex, vec2(u,v));\\n        }\\n    ';\n    Texture3DLike.prototype.GLSL_SAMPLE_LINEAR = '\\n        vec4 sample3D(sampler2D tex, vec3 texcoord, vec3 shape, vec2 tiles) {\\n            shape.xyz = shape.zyx;  // silly row-major convention\\n            float nrows = tiles.y, ncols = tiles.x;\\n            // Don\\'t let adjacent frames be interpolated into this one\\n            texcoord.x = min(texcoord.x * shape.x, shape.x - 0.5);\\n            texcoord.x = max(0.5, texcoord.x) / shape.x;\\n            texcoord.y = min(texcoord.y * shape.y, shape.y - 0.5);\\n            texcoord.y = max(0.5, texcoord.y) / shape.y;\\n\\n            float z = texcoord.z * shape.z;\\n            float zindex1 = floor(z);\\n            float u1 = (mod(zindex1, ncols) + texcoord.x) / ncols;\\n            float v1 = (floor(zindex1 / ncols) + texcoord.y) / nrows;\\n\\n            float zindex2 = zindex1 + 1.0;\\n            float u2 = (mod(zindex2, ncols) + texcoord.x) / ncols;\\n            float v2 = (floor(zindex2 / ncols) + texcoord.y) / nrows;\\n\\n            vec4 s1 = texture2D(tex, vec2(u1, v1));\\n            vec4 s2 = texture2D(tex, vec2(u2, v2));\\n\\n            return s1 * (zindex2 - z) + s2 * (z - zindex1);\\n        }\\n    ';\n    Texture3DLike.prototype._get_tile_info = function (shape) {\n        var err_3, max_size, ncols, nrows;\n        max_size = this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE);\n        nrows = Math.floor(max_size / shape[1]);\n        nrows = Math.min(nrows, shape[0]);\n        ncols = window.Math.ceil(shape[0] / nrows);\n        if (_pyfunc_truthy(_pyfunc_mult(ncols, shape[2]) > max_size)) {\n            err_3 = new Error('RuntimeError:' + ('Cannot fit 3D data with shape ' + shape + ' onto simulated 2D texture.'));\n            err_3.name = 'RuntimeError';\n            throw err_3;\n        }\n        return [\n            nrows,\n            ncols\n        ];\n    };\n    Texture3DLike.prototype.set_size = function (shape, format) {\n        var ncols, nrows, sim_shape, stub18_;\n        // Set the size of the 3D texture.\n        //\n        // Parameters\n        // ----------\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // format : GL enum\n        //     The format of the texture data. Can be LUMINANCE, LUMINANCE_ALPHA,\n        //     RGB, and RGBA.\n        stub18_ = this._get_tile_info(shape);\n        nrows = stub18_[0];\n        ncols = stub18_[1];\n        sim_shape = [\n            _pyfunc_mult(shape[1], nrows),\n            _pyfunc_mult(shape[2], ncols)\n        ];\n        Texture3DLike.prototype._base_class.set_size.call(this, sim_shape, format);\n        this.u_shape = [\n            shape[0],\n            shape[1],\n            shape[2]\n        ];\n        this.u_tiles = [\n            ncols,\n            nrows\n        ];\n        return null;\n    };\n    Texture3DLike.prototype.set_data = function (offset, shape, data) {\n        var Type, col, elements_per_tile, err_3, ncols, nrows, row, sim_shape, stub19_, stub20_, tile, z, zeros;\n        // Set the 3D texture data.\n        //\n        // Parameters\n        // ----------\n        // offset : tuple of ints\n        //     Offset in pixels for each dimension.\n        // shape : tuple of ints\n        //     The shape of the data to upload\n        // data : typed array\n        //     The actual pixel data. Can be of any type, but on the GPU the\n        //     dat is stored in 8 bit precision.\n        if (_pyfunc_equals(shape.length, 3)) {\n            shape = [\n                shape[0],\n                shape[1],\n                shape[2],\n                1\n            ];\n        }\n        if (!_pyfunc_all(function list_comprehenson() {\n                var res = [];\n                var i, iter0, i0;\n                iter0 = offset;\n                if (typeof iter0 === 'object' && !Array.isArray(iter0)) {\n                    iter0 = Object.keys(iter0);\n                }\n                for (i0 = 0; i0 < iter0.length; i0++) {\n                    i = iter0[i0];\n                    {\n                        res.push(_pyfunc_equals(i, 0));\n                    }\n                }\n                return res;\n            }.apply(this))) {\n            err_3 = new Error('ValueError:' + 'Texture3DLike does not support nonzero offset (for now)');\n            err_3.name = 'ValueError';\n            throw err_3;\n        }\n        stub19_ = this._get_tile_info(shape);\n        nrows = stub19_[0];\n        ncols = stub19_[1];\n        sim_shape = [\n            _pyfunc_mult(shape[1], nrows),\n            _pyfunc_mult(shape[2], ncols),\n            shape[3]\n        ];\n        if (_pyfunc_equals(ncols, 1)) {\n            Texture3DLike.prototype._base_class.set_data.call(this, [\n                0,\n                0\n            ], sim_shape, data);\n        } else {\n            Type = data.constructor;\n            zeros = new Type(_pyfunc_mult(_pyfunc_mult(sim_shape[0], sim_shape[1]), sim_shape[2]));\n            Texture3DLike.prototype._base_class.set_data.call(this, [\n                0,\n                0\n            ], sim_shape, zeros);\n            for (z = 0; z < shape[0]; z += 1) {\n                stub20_ = [\n                    Math.floor(z / ncols),\n                    z % ncols\n                ];\n                row = stub20_[0];\n                col = stub20_[1];\n                elements_per_tile = Math.floor(data.length / shape[0]);\n                tile = data.slice(_pyfunc_mult(z, elements_per_tile), _pyfunc_mult(z + 1, elements_per_tile));\n                Texture3DLike.prototype._base_class.set_data.call(this, [\n                    _pyfunc_mult(row, shape[1]),\n                    _pyfunc_mult(col, shape[2])\n                ], shape.slice(1), tile);\n            }\n        }\n        return null;\n    };\n    module.exports = {\n        'Buffer': Buffer,\n        'GlooObject': GlooObject,\n        'IndexBuffer': IndexBuffer,\n        'Program': Program,\n        'Texture2D': Texture2D,\n        'Texture3DLike': Texture3DLike,\n        'VertexBuffer': VertexBuffer,\n        'check_error': check_error,\n        'console': console\n    };    \n}","/*models/glyphs/webgl/index*/\nfunction _(require, module, exports) {\n    var tslib_1 = require(364    /* tslib */);\n    tslib_1.__exportStar(require(426    /* ./line */), exports);\n    tslib_1.__exportStar(require(428    /* ./markers */), exports);    \n}","/*models/glyphs/webgl/line*/\nfunction _(require, module, exports) {\n    var tslib_1 = require(364    /* tslib */);\n    var DashAtlas;\n    var gloo2_1 = require(424    /* ./gloo2 */);\n    var base_1 = require(423    /* ./base */);\n    var color_1 = require(26    /* core/util/color */);\n    DashAtlas = function () {\n        function DashAtlas(gl) {\n            this._atlas = {};\n            this._index = 0;\n            this._width = 256;\n            this._height = 256;\n            // Init texture\n            this.tex = new gloo2_1.Texture2D(gl);\n            this.tex.set_wrapping(gl.REPEAT, gl.REPEAT);\n            this.tex.set_interpolation(gl.NEAREST, gl.NEAREST);\n            this.tex.set_size([\n                this._height,\n                this._width\n            ], gl.RGBA);\n            this.tex.set_data([\n                0,\n                0\n            ], [\n                this._height,\n                this._width\n            ], new Uint8Array(this._height * this._width * 4));\n            // Init with solid line (index 0 is reserved for this)\n            this.get_atlas_data([1]);\n        }\n        DashAtlas.prototype.get_atlas_data = function (pattern) {\n            var data, findex_period, key, period, x;\n            key = pattern.join('-');\n            findex_period = this._atlas[key];\n            if (findex_period === void 0) {\n                _a = this.make_pattern(pattern), data = _a[0], period = _a[1];\n                this.tex.set_data([\n                    this._index,\n                    0\n                ], [\n                    1,\n                    this._width\n                ], new Uint8Array(function () {\n                    var l, len, results;\n                    results = [];\n                    for (l = 0, len = data.length; l < len; l++) {\n                        x = data[l];\n                        results.push(x + 10);\n                    }\n                    return results;\n                }()));\n                this._atlas[key] = [\n                    this._index / this._height,\n                    period\n                ];\n                this._index += 1;\n            }\n            return this._atlas[key];\n            var _a;\n        };\n        DashAtlas.prototype.make_pattern = function (pattern) {\n            var C, Z, a, b, c, dash_end, dash_start, dash_type, i, index, j, l, len, n, p, period, q, r, ref, ref1, ref2, v, val, val_at_index, x;\n            // A pattern is defined as on/off sequence of segments\n            // It must be a multiple of 2\n            if (pattern.length > 1 && pattern.length % 2) {\n                pattern = pattern.concat(pattern);\n            }\n            // Period is sum of elements\n            period = 0;\n            for (l = 0, len = pattern.length; l < len; l++) {\n                v = pattern[l];\n                period += v;\n            }\n            // Find all start and end of on-segment only\n            C = [];\n            c = 0;\n            for (i = p = 0, ref = pattern.length + 2; p < ref; i = p += 2) {\n                a = Math.max(0.0001, pattern[i % pattern.length]);\n                b = Math.max(0.0001, pattern[(i + 1) % pattern.length]);\n                C.push.apply(C, [\n                    c,\n                    c + a    // == extend\n                ]);\n                c += a + b;\n            }\n            // Build pattern\n            n = this._width;\n            Z = new Float32Array(n * 4);\n            for (i = q = 0, ref1 = n; 0 <= ref1 ? q < ref1 : q > ref1; i = 0 <= ref1 ? ++q : --q) {\n                x = period * i / (n - 1);\n                // get index at min - index = np.argmin(abs(C-(x)))\n                index = 0;\n                val_at_index = 10000000000000000;\n                for (j = r = 0, ref2 = C.length; 0 <= ref2 ? r < ref2 : r > ref2; j = 0 <= ref2 ? ++r : --r) {\n                    val = Math.abs(C[j] - x);\n                    if (val < val_at_index) {\n                        index = j;\n                        val_at_index = val;\n                    }\n                }\n                if (index % 2 === 0) {\n                    dash_type = x <= C[index] ? +1 : 0;\n                    dash_start = C[index];\n                    dash_end = C[index + 1];\n                } else {\n                    dash_type = x > C[index] ? -1 : 0;\n                    dash_start = C[index - 1];\n                    dash_end = C[index];\n                }\n                Z[i * 4 + 0] = C[index];\n                Z[i * 4 + 1] = dash_type;\n                Z[i * 4 + 2] = dash_start;\n                Z[i * 4 + 3] = dash_end;\n            }\n            return [\n                Z,\n                period\n            ];\n        };\n        return DashAtlas;\n    }();\n    var LineGLGlyph = function (_super) {\n        tslib_1.__extends(LineGLGlyph, _super);\n        function LineGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        LineGLGlyph.prototype.init = function () {\n            var gl;\n            gl = this.gl;\n            this._scale_aspect = 0;\n            // keep track, so we know when we need to update segment data\n            // The program\n            this.prog = new gloo2_1.Program(gl);\n            this.prog.set_shaders(this.VERT, this.FRAG);\n            this.index_buffer = new gloo2_1.IndexBuffer(gl);\n            // Buffers\n            this.vbo_position = new gloo2_1.VertexBuffer(gl);\n            this.vbo_tangents = new gloo2_1.VertexBuffer(gl);\n            this.vbo_segment = new gloo2_1.VertexBuffer(gl);\n            this.vbo_angles = new gloo2_1.VertexBuffer(gl);\n            this.vbo_texcoord = new gloo2_1.VertexBuffer(gl);\n            // Dash atlas\n            return this.dash_atlas = new DashAtlas(gl);\n        };\n        LineGLGlyph.prototype.draw = function (indices, mainGlyph, trans) {\n            var baked_offset, chunk, chunks, chunksize, i, l, mainGlGlyph, nvertices, offset, p, q, ref, ref1, ref2, results, scale_length, sx, sy, these_indices, uint16_index;\n            mainGlGlyph = mainGlyph.glglyph;\n            if (mainGlGlyph.data_changed) {\n                if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                    return;\n                }\n                mainGlGlyph._baked_offset = [\n                    trans.dx,\n                    trans.dy\n                ];\n                mainGlGlyph._set_data();\n                mainGlGlyph.data_changed = false;\n            }\n            if (this.visuals_changed) {\n                this._set_visuals();\n                this.visuals_changed = false;\n            }\n            // Decompose x-y scale into scalar scale and aspect-vector.\n            sx = trans.sx;\n            sy = trans.sy;\n            scale_length = Math.sqrt(sx * sx + sy * sy);\n            sx /= scale_length;\n            sy /= scale_length;\n            // Do we need to re-calculate segment data and cumsum?\n            if (Math.abs(this._scale_aspect - sy / sx) > Math.abs(0.001 * this._scale_aspect)) {\n                mainGlGlyph._update_scale(sx, sy);\n                this._scale_aspect = sy / sx;\n            }\n            // Select buffers from main glyph\n            // (which may be this glyph but maybe not if this is a (non)selection glyph)\n            this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position);\n            this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents);\n            this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment);\n            this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles);\n            this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord);\n            this.prog.set_uniform('u_length', 'float', [mainGlGlyph.cumsum]);\n            this.prog.set_texture('u_dash_atlas', this.dash_atlas.tex);\n            // Handle transformation to device coordinates\n            baked_offset = mainGlGlyph._baked_offset;\n            this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n            this.prog.set_uniform('u_canvas_size', 'vec2', [\n                trans.width,\n                trans.height\n            ]);\n            this.prog.set_uniform('u_offset', 'vec2', [\n                trans.dx - baked_offset[0],\n                trans.dy - baked_offset[1]\n            ]);\n            this.prog.set_uniform('u_scale_aspect', 'vec2', [\n                sx,\n                sy\n            ]);\n            this.prog.set_uniform('u_scale_length', 'float', [scale_length]);\n            this.I_triangles = mainGlGlyph.I_triangles;\n            if (this.I_triangles.length < 65535) {\n                // Data is small enough to draw in one pass\n                this.index_buffer.set_size(this.I_triangles.length * 2);\n                this.index_buffer.set_data(0, new Uint16Array(this.I_triangles));\n                return this.prog.draw(this.gl.TRIANGLES, this.index_buffer);\n            } else {\n                // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n                // First collect indices in chunks\n                // @prog.draw(@gl.LINE_STRIP, @index_buffer)  # Use this to draw the line skeleton\n                indices = this.I_triangles;\n                nvertices = this.I_triangles.length;\n                chunksize = 64008;\n                // 65536 max. 64008 is divisible by 12\n                chunks = [];\n                for (i = l = 0, ref = Math.ceil(nvertices / chunksize); 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n                    chunks.push([]);\n                }\n                for (i = p = 0, ref1 = indices.length; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n                    uint16_index = indices[i] % chunksize;\n                    chunk = Math.floor(indices[i] / chunksize);\n                    chunks[chunk].push(uint16_index);\n                }\n                results = [];\n                // Then draw each chunk\n                for (chunk = q = 0, ref2 = chunks.length; 0 <= ref2 ? q < ref2 : q > ref2; chunk = 0 <= ref2 ? ++q : --q) {\n                    these_indices = new Uint16Array(chunks[chunk]);\n                    offset = chunk * chunksize * 4;\n                    if (these_indices.length === 0) {\n                        continue;\n                    }\n                    this.prog.set_attribute('a_position', 'vec2', mainGlGlyph.vbo_position, 0, offset * 2);\n                    this.prog.set_attribute('a_tangents', 'vec4', mainGlGlyph.vbo_tangents, 0, offset * 4);\n                    this.prog.set_attribute('a_segment', 'vec2', mainGlGlyph.vbo_segment, 0, offset * 2);\n                    this.prog.set_attribute('a_angles', 'vec2', mainGlGlyph.vbo_angles, 0, offset * 2);\n                    this.prog.set_attribute('a_texcoord', 'vec2', mainGlGlyph.vbo_texcoord, 0, offset * 2);\n                    // The actual drawing\n                    this.index_buffer.set_size(these_indices.length * 2);\n                    this.index_buffer.set_data(0, these_indices);\n                    results.push(this.prog.draw(this.gl.TRIANGLES, this.index_buffer));\n                }\n                return results;\n            }\n        };\n        LineGLGlyph.prototype._set_data = function () {\n            this._bake();\n            this.vbo_position.set_size(this.V_position.length * 4);\n            this.vbo_position.set_data(0, this.V_position);\n            this.vbo_tangents.set_size(this.V_tangents.length * 4);\n            this.vbo_tangents.set_data(0, this.V_tangents);\n            this.vbo_angles.set_size(this.V_angles.length * 4);\n            this.vbo_angles.set_data(0, this.V_angles);\n            this.vbo_texcoord.set_size(this.V_texcoord.length * 4);\n            return this.vbo_texcoord.set_data(0, this.V_texcoord);\n        };\n        LineGLGlyph.prototype._set_visuals = function () {\n            var cap, color, dash_index, dash_pattern, dash_period, join;\n            color = color_1.color2rgba(this.glyph.visuals.line.line_color.value(), this.glyph.visuals.line.line_alpha.value());\n            cap = this.CAPS[this.glyph.visuals.line.line_cap.value()];\n            join = this.JOINS[this.glyph.visuals.line.line_join.value()];\n            this.prog.set_uniform('u_color', 'vec4', color);\n            this.prog.set_uniform('u_linewidth', 'float', [this.glyph.visuals.line.line_width.value()]);\n            this.prog.set_uniform('u_antialias', 'float', [0.9]);\n            // Smaller aa-region to obtain crisper images\n            this.prog.set_uniform('u_linecaps', 'vec2', [\n                cap,\n                cap\n            ]);\n            this.prog.set_uniform('u_linejoin', 'float', [join]);\n            this.prog.set_uniform('u_miter_limit', 'float', [10]);\n            // 10 should be a good value\n            // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-miterlimit\n            dash_pattern = this.glyph.visuals.line.line_dash.value();\n            dash_index = 0;\n            dash_period = 1;\n            if (dash_pattern.length) {\n                _a = this.dash_atlas.get_atlas_data(dash_pattern), dash_index = _a[0], dash_period = _a[1];\n            }\n            this.prog.set_uniform('u_dash_index', 'float', [dash_index]);\n            // 0 means solid line\n            this.prog.set_uniform('u_dash_phase', 'float', [this.glyph.visuals.line.line_dash_offset.value()]);\n            this.prog.set_uniform('u_dash_period', 'float', [dash_period]);\n            this.prog.set_uniform('u_dash_caps', 'vec2', [\n                cap,\n                cap\n            ]);\n            return this.prog.set_uniform('u_closed', 'float', [0]);\n            // We dont do closed lines\n            var _a;\n        };\n        LineGLGlyph.prototype._bake = function () {\n            var A, I, T, V_angles, V_angles2, V_position, V_position2, V_tangents, V_tangents2, V_texcoord, V_texcoord2, Vp, Vt, _x, _y, i, i1, j, k, l, m, n, ni, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, results, s, t, u, w, y, z;\n            // This is what you get if you port 50 lines of numpy code to JS.\n            // V_segment is handled in another method, because it depends on the aspect\n            // ratio of the scale (The original paper/code assumed isotropic scaling).\n            // Buffer dtype from the Python implementation:\n            // self.vtype = np.dtype( [('a_position', 'f4', 2),\n            //                         ('a_segment',  'f4', 2),\n            //                         ('a_angles',   'f4', 2),\n            //                         ('a_tangents', 'f4', 4),\n            //                         ('a_texcoord', 'f4', 2) ])\n            // Init array of implicit shape nx2\n            n = this.nvertices;\n            _x = new Float64Array(this.glyph._x);\n            _y = new Float64Array(this.glyph._y);\n            // Init vertex data\n            V_position = Vp = new Float32Array(n * 2);\n            //V_segment = new Float32Array(n*2)  # Done later\n            V_angles = new Float32Array(n * 2);\n            V_tangents = Vt = new Float32Array(n * 4);\n            // mind the 4!\n            V_texcoord = new Float32Array(n * 2);\n            // Position\n            for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n                V_position[i * 2 + 0] = _x[i] + this._baked_offset[0];\n                V_position[i * 2 + 1] = _y[i] + this._baked_offset[1];\n            }\n            // Tangents & norms (need tangents to calculate segments based on scale)\n            this.tangents = T = new Float32Array(n * 2 - 2);\n            for (i = p = 0, ref1 = n - 1; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n                T[i * 2 + 0] = Vp[(i + 1) * 2 + 0] - Vp[i * 2 + 0];\n                T[i * 2 + 1] = Vp[(i + 1) * 2 + 1] - Vp[i * 2 + 1];\n            }\n            for (i = q = 0, ref2 = n - 1; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {\n                // V['a_tangents'][+1:, :2] = T\n                V_tangents[(i + 1) * 4 + 0] = T[i * 2 + 0];\n                V_tangents[(i + 1) * 4 + 1] = T[i * 2 + 1];\n                // V['a_tangents'][:-1, 2:] = T\n                V_tangents[i * 4 + 2] = T[i * 2 + 0];\n                V_tangents[i * 4 + 3] = T[i * 2 + 1];\n            }\n            // V['a_tangents'][0  , :2] = T[0]\n            V_tangents[0 * 4 + 0] = T[0];\n            V_tangents[0 * 4 + 1] = T[1];\n            // V['a_tangents'][ -1, 2:] = T[-1]\n            V_tangents[(n - 1) * 4 + 2] = T[(n - 2) * 2 + 0];\n            V_tangents[(n - 1) * 4 + 3] = T[(n - 2) * 2 + 1];\n            // Angles\n            A = new Float32Array(n);\n            for (i = r = 0, ref3 = n; 0 <= ref3 ? r < ref3 : r > ref3; i = 0 <= ref3 ? ++r : --r) {\n                A[i] = Math.atan2(Vt[i * 4 + 0] * Vt[i * 4 + 3] - Vt[i * 4 + 1] * Vt[i * 4 + 2], Vt[i * 4 + 0] * Vt[i * 4 + 2] + Vt[i * 4 + 1] * Vt[i * 4 + 3]);\n            }\n            for (i = s = 0, ref4 = n - 1; 0 <= ref4 ? s < ref4 : s > ref4; i = 0 <= ref4 ? ++s : --s) {\n                V_angles[i * 2 + 0] = A[i];\n                V_angles[i * 2 + 1] = A[i + 1];\n            }\n            // Step 1: A -- B -- C  =>  A -- B, B' -- C\n            // Repeat our array 4 times\n            m = 4 * n - 4;\n            this.V_position = V_position2 = new Float32Array(m * 2);\n            this.V_angles = V_angles2 = new Float32Array(m * 2);\n            this.V_tangents = V_tangents2 = new Float32Array(m * 4);\n            // mind the 4!\n            this.V_texcoord = V_texcoord2 = new Float32Array(m * 2);\n            o = 2;\n            // all nodes on the line\n            // Arg, we really need an ndarray thing in JS :/\n            for (i = t = 0, ref5 = n; 0 <= ref5 ? t < ref5 : t > ref5; i = 0 <= ref5 ? ++t : --t) {\n                // the four quad vertices\n                for (j = u = 0; u < 4; j = ++u) {\n                    // xy\n                    for (k = w = 0; w < 2; k = ++w) {\n                        V_position2[(i * 4 + j - o) * 2 + k] = V_position[i * 2 + k];\n                        V_angles2[(i * 4 + j) * 2 + k] = V_angles[i * 2 + k];\n                    }\n                    for (k = y = 0; y < 4; k = ++y) {\n                        V_tangents2[(i * 4 + j - o) * 4 + k] = V_tangents[i * 4 + k];\n                    }\n                }\n            }\n            for (i = z = 0, ref6 = n; 0 <= ref6 ? z <= ref6 : z >= ref6; i = 0 <= ref6 ? ++z : --z) {\n                V_texcoord2[(i * 4 + 0) * 2 + 0] = -1;\n                V_texcoord2[(i * 4 + 1) * 2 + 0] = -1;\n                V_texcoord2[(i * 4 + 2) * 2 + 0] = +1;\n                V_texcoord2[(i * 4 + 3) * 2 + 0] = +1;\n                V_texcoord2[(i * 4 + 0) * 2 + 1] = -1;\n                V_texcoord2[(i * 4 + 1) * 2 + 1] = +1;\n                V_texcoord2[(i * 4 + 2) * 2 + 1] = -1;\n                V_texcoord2[(i * 4 + 3) * 2 + 1] = +1;\n            }\n            // Indices\n            //I = np.resize( np.array([0,1,2,1,2,3], dtype=np.uint32), (n-1)*(2*3))\n            //I += np.repeat( 4*np.arange(n-1), 6)\n            ni = (n - 1) * 6;\n            this.I_triangles = I = new Uint32Array(ni);\n            results = [];\n            // Order of indices is such that drawing as line_strip reveals the line skeleton\n            // Might have implications on culling, if we ever turn that on.\n            // Order in paper was: 0 1 2 1 2 3\n            for (i = i1 = 0, ref7 = n; 0 <= ref7 ? i1 < ref7 : i1 > ref7; i = 0 <= ref7 ? ++i1 : --i1) {\n                I[i * 6 + 0] = 0 + 4 * i;\n                I[i * 6 + 1] = 1 + 4 * i;\n                I[i * 6 + 2] = 3 + 4 * i;\n                I[i * 6 + 3] = 2 + 4 * i;\n                I[i * 6 + 4] = 0 + 4 * i;\n                results.push(I[i * 6 + 5] = 3 + 4 * i);\n            }\n            return results;\n        };\n        LineGLGlyph.prototype._update_scale = function (sx, sy) {\n            var N, T, V_segment, V_segment2, cumsum, i, j, k, l, m, n, p, q, r, ref, ref1, ref2, s;\n            // Update segment data and cumsum so the length along the line has the\n            // scale aspect ratio in it. In the vertex shader we multiply with the\n            // \"isotropic part\" of the scale.\n            n = this.nvertices;\n            m = 4 * n - 4;\n            // Prepare arrays\n            T = this.tangents;\n            N = new Float32Array(n - 1);\n            V_segment = new Float32Array(n * 2);\n            // Elements are initialized with 0\n            this.V_segment = V_segment2 = new Float32Array(m * 2);\n            // Calculate vector lengths - with scale aspect ratio taken into account\n            for (i = l = 0, ref = n - 1; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {\n                N[i] = Math.sqrt(Math.pow(T[i * 2 + 0] * sx, 2) + Math.pow(T[i * 2 + 1] * sy, 2));\n            }\n            // Calculate Segments\n            cumsum = 0;\n            for (i = p = 0, ref1 = n - 1; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {\n                cumsum += N[i];\n                V_segment[(i + 1) * 2 + 0] = cumsum;\n                V_segment[i * 2 + 1] = cumsum;\n            }\n            // Upscale (same loop as in _bake())\n            for (i = q = 0, ref2 = n; 0 <= ref2 ? q < ref2 : q > ref2; i = 0 <= ref2 ? ++q : --q) {\n                for (j = r = 0; r < 4; j = ++r) {\n                    for (k = s = 0; s < 2; k = ++s) {\n                        V_segment2[(i * 4 + j) * 2 + k] = V_segment[i * 2 + k];\n                    }\n                }\n            }\n            // Update\n            this.cumsum = cumsum;\n            // L[-1] in Nico's code\n            this.vbo_segment.set_size(this.V_segment.length * 4);\n            return this.vbo_segment.set_data(0, this.V_segment);\n        };\n        return LineGLGlyph;\n    }(base_1.BaseGLGlyph);\n    exports.LineGLGlyph = LineGLGlyph;\n    ;\n    LineGLGlyph.prototype.GLYPH = 'line';\n    LineGLGlyph.prototype.JOINS = {\n        'miter': 0,\n        'round': 1,\n        'bevel': 2\n    };\n    LineGLGlyph.prototype.CAPS = {\n        '': 0,\n        'none': 0,\n        '.': 0,\n        'round': 1,\n        ')': 1,\n        '(': 1,\n        'o': 1,\n        'triangle in': 2,\n        '<': 2,\n        'triangle out': 3,\n        '>': 3,\n        'square': 4,\n        '[': 4,\n        ']': 4,\n        '=': 4,\n        'butt': 5,\n        '|': 5\n    };\n    LineGLGlyph.prototype.VERT = 'precision mediump float;\\n\\nconst float PI = 3.14159265358979323846264;\\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\\n\\nuniform float u_pixel_ratio;\\nuniform vec2 u_canvas_size, u_offset;\\nuniform vec2 u_scale_aspect;\\nuniform float u_scale_length;\\n\\nuniform vec4 u_color;\\nuniform float u_antialias;\\nuniform float u_length;\\nuniform float u_linewidth;\\nuniform float u_dash_index;\\nuniform float u_closed;\\n\\nattribute vec2 a_position;\\nattribute vec4 a_tangents;\\nattribute vec2 a_segment;\\nattribute vec2 a_angles;\\nattribute vec2 a_texcoord;\\n\\nvarying vec4  v_color;\\nvarying vec2  v_segment;\\nvarying vec2  v_angles;\\nvarying vec2  v_texcoord;\\nvarying vec2  v_miter;\\nvarying float v_length;\\nvarying float v_linewidth;\\n\\nfloat cross(in vec2 v1, in vec2 v2)\\n{\\n    return v1.x*v2.y - v1.y*v2.x;\\n}\\n\\nfloat signed_distance(in vec2 v1, in vec2 v2, in vec2 v3)\\n{\\n    return cross(v2-v1,v1-v3) / length(v2-v1);\\n}\\n\\nvoid rotate( in vec2 v, in float alpha, out vec2 result )\\n{\\n    float c = cos(alpha);\\n    float s = sin(alpha);\\n    result = vec2( c*v.x - s*v.y,\\n                   s*v.x + c*v.y );\\n}\\n\\nvoid main()\\n{\\n    bool closed = (u_closed > 0.0);\\n\\n    // Attributes and uniforms to varyings\\n    v_color = u_color;\\n    v_linewidth = u_linewidth;\\n    v_segment = a_segment * u_scale_length;\\n    v_length = u_length * u_scale_length;\\n\\n    // Scale to map to pixel coordinates. The original algorithm from the paper\\n    // assumed isotropic scale. We obviously do not have this.\\n    vec2 abs_scale_aspect = abs(u_scale_aspect);\\n    vec2 abs_scale = u_scale_length * abs_scale_aspect;\\n\\n    // Correct angles for aspect ratio\\n    vec2 av;\\n    av = vec2(1.0, tan(a_angles.x)) / abs_scale_aspect;\\n    v_angles.x = atan(av.y, av.x);\\n    av = vec2(1.0, tan(a_angles.y)) / abs_scale_aspect;\\n    v_angles.y = atan(av.y, av.x);\\n\\n    // Thickness below 1 pixel are represented using a 1 pixel thickness\\n    // and a modified alpha\\n    v_color.a = min(v_linewidth, v_color.a);\\n    v_linewidth = max(v_linewidth, 1.0);\\n\\n    // If color is fully transparent we just will discard the fragment anyway\\n    if( v_color.a <= 0.0 ) {\\n        gl_Position = vec4(0.0,0.0,0.0,1.0);\\n        return;\\n    }\\n\\n    // This is the actual half width of the line\\n    float w = ceil(u_antialias+v_linewidth)/2.0;\\n\\n    vec2 position = (a_position + u_offset) * abs_scale;\\n\\n    vec2 t1 = normalize(a_tangents.xy * abs_scale_aspect);  // note the scaling for aspect ratio here\\n    vec2 t2 = normalize(a_tangents.zw * abs_scale_aspect);\\n    float u = a_texcoord.x;\\n    float v = a_texcoord.y;\\n    vec2 o1 = vec2( +t1.y, -t1.x);\\n    vec2 o2 = vec2( +t2.y, -t2.x);\\n\\n    // This is a join\\n    // ----------------------------------------------------------------\\n    if( t1 != t2 ) {\\n        float angle = atan (t1.x*t2.y-t1.y*t2.x, t1.x*t2.x+t1.y*t2.y);  // Angle needs recalculation for some reason\\n        vec2 t  = normalize(t1+t2);\\n        vec2 o  = vec2( + t.y, - t.x);\\n\\n        if ( u_dash_index > 0.0 )\\n        {\\n            // Broken angle\\n            // ----------------------------------------------------------------\\n            if( (abs(angle) > THETA) ) {\\n                position += v * w * o / cos(angle/2.0);\\n                float s = sign(angle);\\n                if( angle < 0.0 ) {\\n                    if( u == +1.0 ) {\\n                        u = v_segment.y + v * w * tan(angle/2.0);\\n                        if( v == 1.0 ) {\\n                            position -= 2.0 * w * t1 / sin(angle);\\n                            u -= 2.0 * w / sin(angle);\\n                        }\\n                    } else {\\n                        u = v_segment.x - v * w * tan(angle/2.0);\\n                        if( v == 1.0 ) {\\n                            position += 2.0 * w * t2 / sin(angle);\\n                            u += 2.0*w / sin(angle);\\n                        }\\n                    }\\n                } else {\\n                    if( u == +1.0 ) {\\n                        u = v_segment.y + v * w * tan(angle/2.0);\\n                        if( v == -1.0 ) {\\n                            position += 2.0 * w * t1 / sin(angle);\\n                            u += 2.0 * w / sin(angle);\\n                        }\\n                    } else {\\n                        u = v_segment.x - v * w * tan(angle/2.0);\\n                        if( v == -1.0 ) {\\n                            position -= 2.0 * w * t2 / sin(angle);\\n                            u -= 2.0*w / sin(angle);\\n                        }\\n                    }\\n                }\\n                // Continuous angle\\n                // ------------------------------------------------------------\\n            } else {\\n                position += v * w * o / cos(angle/2.0);\\n                if( u == +1.0 ) u = v_segment.y;\\n                else            u = v_segment.x;\\n            }\\n        }\\n\\n        // Solid line\\n        // --------------------------------------------------------------------\\n        else\\n        {\\n            position.xy += v * w * o / cos(angle/2.0);\\n            if( angle < 0.0 ) {\\n                if( u == +1.0 ) {\\n                    u = v_segment.y + v * w * tan(angle/2.0);\\n                } else {\\n                    u = v_segment.x - v * w * tan(angle/2.0);\\n                }\\n            } else {\\n                if( u == +1.0 ) {\\n                    u = v_segment.y + v * w * tan(angle/2.0);\\n                } else {\\n                    u = v_segment.x - v * w * tan(angle/2.0);\\n                }\\n            }\\n        }\\n\\n    // This is a line start or end (t1 == t2)\\n    // ------------------------------------------------------------------------\\n    } else {\\n        position += v * w * o1;\\n        if( u == -1.0 ) {\\n            u = v_segment.x - w;\\n            position -= w * t1;\\n        } else {\\n            u = v_segment.y + w;\\n            position += w * t2;\\n        }\\n    }\\n\\n    // Miter distance\\n    // ------------------------------------------------------------------------\\n    vec2 t;\\n    vec2 curr = a_position * abs_scale;\\n    if( a_texcoord.x < 0.0 ) {\\n        vec2 next = curr + t2*(v_segment.y-v_segment.x);\\n\\n        rotate( t1, +v_angles.x/2.0, t);\\n        v_miter.x = signed_distance(curr, curr+t, position);\\n\\n        rotate( t2, +v_angles.y/2.0, t);\\n        v_miter.y = signed_distance(next, next+t, position);\\n    } else {\\n        vec2 prev = curr - t1*(v_segment.y-v_segment.x);\\n\\n        rotate( t1, -v_angles.x/2.0,t);\\n        v_miter.x = signed_distance(prev, prev+t, position);\\n\\n        rotate( t2, -v_angles.y/2.0,t);\\n        v_miter.y = signed_distance(curr, curr+t, position);\\n    }\\n\\n    if (!closed && v_segment.x <= 0.0) {\\n        v_miter.x = 1e10;\\n    }\\n    if (!closed && v_segment.y >= v_length)\\n    {\\n        v_miter.y = 1e10;\\n    }\\n\\n    v_texcoord = vec2( u, v*w );\\n\\n    // Calculate position in device coordinates. Note that we\\n    // already scaled with abs scale above.\\n    vec2 normpos = position * sign(u_scale_aspect);\\n    normpos += 0.5;  // make up for Bokeh\\'s offset\\n    normpos /= u_canvas_size / u_pixel_ratio;  // in 0..1\\n    gl_Position = vec4(normpos*2.0-1.0, 0.0, 1.0);\\n    gl_Position.y *= -1.0;\\n}\\n';\n    LineGLGlyph.prototype.FRAG_ = '// Fragment shader that can be convenient during debugging to show the line skeleton.\\nprecision mediump float;\\nuniform vec4  u_color;\\nvoid main () {\\n  gl_FragColor = u_color;\\n}';\n    LineGLGlyph.prototype.FRAG = 'precision mediump float;\\n\\nconst float PI = 3.14159265358979323846264;\\nconst float THETA = 15.0 * 3.14159265358979323846264/180.0;\\n\\nuniform sampler2D u_dash_atlas;\\n\\nuniform vec2 u_linecaps;\\nuniform float u_miter_limit;\\nuniform float u_linejoin;\\nuniform float u_antialias;\\nuniform float u_dash_phase;\\nuniform float u_dash_period;\\nuniform float u_dash_index;\\nuniform vec2 u_dash_caps;\\nuniform float u_closed;\\n\\nvarying vec4  v_color;\\nvarying vec2  v_segment;\\nvarying vec2  v_angles;\\nvarying vec2  v_texcoord;\\nvarying vec2  v_miter;\\nvarying float v_length;\\nvarying float v_linewidth;\\n\\n// Compute distance to cap ----------------------------------------------------\\nfloat cap( int type, float dx, float dy, float t, float linewidth )\\n{\\n    float d = 0.0;\\n    dx = abs(dx);\\n    dy = abs(dy);\\n    if      (type == 0)  discard;  // None\\n    else if (type == 1)  d = sqrt(dx*dx+dy*dy);  // Round\\n    else if (type == 3)  d = (dx+abs(dy));  // Triangle in\\n    else if (type == 2)  d = max(abs(dy),(t+dx-abs(dy)));  // Triangle out\\n    else if (type == 4)  d = max(dx,dy);  // Square\\n    else if (type == 5)  d = max(dx+t,dy);  // Butt\\n    return d;\\n}\\n\\n// Compute distance to join -------------------------------------------------\\nfloat join( in int type, in float d, in vec2 segment, in vec2 texcoord, in vec2 miter,\\n           in float linewidth )\\n{\\n    // texcoord.x is distance from start\\n    // texcoord.y is distance from centerline\\n    // segment.x and y indicate the limits (as for texcoord.x) for this segment\\n\\n    float dx = texcoord.x;\\n\\n    // Round join\\n    if( type == 1 ) {\\n        if (dx < segment.x) {\\n            d = max(d,length( texcoord - vec2(segment.x,0.0)));\\n            //d = length( texcoord - vec2(segment.x,0.0));\\n        } else if (dx > segment.y) {\\n            d = max(d,length( texcoord - vec2(segment.y,0.0)));\\n            //d = length( texcoord - vec2(segment.y,0.0));\\n        }\\n    }\\n    // Bevel join\\n    else if ( type == 2 ) {\\n        if (dx < segment.x) {\\n            vec2 x = texcoord - vec2(segment.x,0.0);\\n            d = max(d, max(abs(x.x), abs(x.y)));\\n\\n        } else if (dx > segment.y) {\\n            vec2 x = texcoord - vec2(segment.y,0.0);\\n            d = max(d, max(abs(x.x), abs(x.y)));\\n        }\\n        /*  Original code for bevel which does not work for us\\n        if( (dx < segment.x) ||  (dx > segment.y) )\\n            d = max(d, min(abs(x.x),abs(x.y)));\\n        */\\n    }\\n\\n    return d;\\n}\\n\\nvoid main()\\n{\\n    // If color is fully transparent we just discard the fragment\\n    if( v_color.a <= 0.0 ) {\\n        discard;\\n    }\\n\\n    // Test if dash pattern is the solid one (0)\\n    bool solid =  (u_dash_index == 0.0);\\n\\n    // Test if path is closed\\n    bool closed = (u_closed > 0.0);\\n\\n    vec4 color = v_color;\\n    float dx = v_texcoord.x;\\n    float dy = v_texcoord.y;\\n    float t = v_linewidth/2.0-u_antialias;\\n    float width = 1.0;  //v_linewidth; original code had dashes scale with line width, we do not\\n    float d = 0.0;\\n\\n    vec2 linecaps = u_linecaps;\\n    vec2 dash_caps = u_dash_caps;\\n    float line_start = 0.0;\\n    float line_stop = v_length;\\n\\n    // Apply miter limit; fragments too far into the miter are simply discarded\\n    if( (dx < v_segment.x) || (dx > v_segment.y) ) {\\n        float into_miter = max(v_segment.x - dx, dx - v_segment.y);\\n        if (into_miter > u_miter_limit*v_linewidth/2.0)\\n          discard;\\n    }\\n\\n    // Solid line --------------------------------------------------------------\\n    if( solid ) {\\n        d = abs(dy);\\n        if( (!closed) && (dx < line_start) ) {\\n            d = cap( int(u_linecaps.x), abs(dx), abs(dy), t, v_linewidth );\\n        }\\n        else if( (!closed) &&  (dx > line_stop) ) {\\n            d = cap( int(u_linecaps.y), abs(dx)-line_stop, abs(dy), t, v_linewidth );\\n        }\\n        else {\\n            d = join( int(u_linejoin), abs(dy), v_segment, v_texcoord, v_miter, v_linewidth );\\n        }\\n\\n    // Dash line --------------------------------------------------------------\\n    } else {\\n        float segment_start = v_segment.x;\\n        float segment_stop  = v_segment.y;\\n        float segment_center= (segment_start+segment_stop)/2.0;\\n        float freq          = u_dash_period*width;\\n        float u = mod( dx + u_dash_phase*width, freq);\\n        vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n        float dash_center= tex.x * width;\\n        float dash_type  = tex.y;\\n        float _start = tex.z * width;\\n        float _stop  = tex.a * width;\\n        float dash_start = dx - u + _start;\\n        float dash_stop  = dx - u + _stop;\\n\\n        // Compute extents of the first dash (the one relative to v_segment.x)\\n        // Note: this could be computed in the vertex shader\\n        if( (dash_stop < segment_start) && (dash_caps.x != 5.0) ) {\\n            float u = mod(segment_start + u_dash_phase*width, freq);\\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n            dash_center= tex.x * width;\\n            //dash_type  = tex.y;\\n            float _start = tex.z * width;\\n            float _stop  = tex.a * width;\\n            dash_start = segment_start - u + _start;\\n            dash_stop = segment_start - u + _stop;\\n        }\\n\\n        // Compute extents of the last dash (the one relatives to v_segment.y)\\n        // Note: This could be computed in the vertex shader\\n        else if( (dash_start > segment_stop)  && (dash_caps.y != 5.0) ) {\\n            float u = mod(segment_stop + u_dash_phase*width, freq);\\n            vec4 tex = texture2D(u_dash_atlas, vec2(u/freq, u_dash_index)) * 255.0 -10.0;  // conversion to int-like\\n            dash_center= tex.x * width;\\n            //dash_type  = tex.y;\\n            float _start = tex.z * width;\\n            float _stop  = tex.a * width;\\n            dash_start = segment_stop - u + _start;\\n            dash_stop  = segment_stop - u + _stop;\\n        }\\n\\n        // This test if the we are dealing with a discontinuous angle\\n        bool discontinuous = ((dx <  segment_center) && abs(v_angles.x) > THETA) ||\\n                             ((dx >= segment_center) && abs(v_angles.y) > THETA);\\n        //if( dx < line_start) discontinuous = false;\\n        //if( dx > line_stop)  discontinuous = false;\\n\\n        float d_join = join( int(u_linejoin), abs(dy),\\n                            v_segment, v_texcoord, v_miter, v_linewidth );\\n\\n        // When path is closed, we do not have room for linecaps, so we make room\\n        // by shortening the total length\\n        if (closed) {\\n             line_start += v_linewidth/2.0;\\n             line_stop  -= v_linewidth/2.0;\\n        }\\n\\n        // We also need to take antialias area into account\\n        //line_start += u_antialias;\\n        //line_stop  -= u_antialias;\\n\\n        // Check is dash stop is before line start\\n        if( dash_stop <= line_start ) {\\n            discard;\\n        }\\n        // Check is dash start is beyond line stop\\n        if( dash_start >= line_stop ) {\\n            discard;\\n        }\\n\\n        // Check if current dash start is beyond segment stop\\n        if( discontinuous ) {\\n            // Dash start is beyond segment, we discard\\n            if( (dash_start > segment_stop) ) {\\n                discard;\\n                //gl_FragColor = vec4(1.0,0.0,0.0,.25); return;\\n            }\\n\\n            // Dash stop is before segment, we discard\\n            if( (dash_stop < segment_start) ) {\\n                discard;  //gl_FragColor = vec4(0.0,1.0,0.0,.25); return;\\n            }\\n\\n            // Special case for round caps (nicer with this)\\n            if( dash_caps.x == 1.0 ) {\\n                if( (u > _stop) && (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0)) {\\n                    discard;\\n                }\\n            }\\n\\n            // Special case for round caps  (nicer with this)\\n            if( dash_caps.y == 1.0 ) {\\n                if( (u < _start) && (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0)) {\\n                    discard;\\n                }\\n            }\\n\\n            // Special case for triangle caps (in & out) and square\\n            // We make sure the cap stop at crossing frontier\\n            if( (dash_caps.x != 1.0) && (dash_caps.x != 5.0) ) {\\n                if( (dash_start < segment_start )  && (abs(v_angles.x) < PI/2.0) ) {\\n                    float a = v_angles.x/2.0;\\n                    float x = (segment_start-dx)*cos(a) - dy*sin(a);\\n                    float y = (segment_start-dx)*sin(a) + dy*cos(a);\\n                    if( x > 0.0 ) discard;\\n                    // We transform the cap into square to avoid holes\\n                    dash_caps.x = 4.0;\\n                }\\n            }\\n\\n            // Special case for triangle caps (in & out) and square\\n            // We make sure the cap stop at crossing frontier\\n            if( (dash_caps.y != 1.0) && (dash_caps.y != 5.0) ) {\\n                if( (dash_stop > segment_stop )  && (abs(v_angles.y) < PI/2.0) ) {\\n                    float a = v_angles.y/2.0;\\n                    float x = (dx-segment_stop)*cos(a) - dy*sin(a);\\n                    float y = (dx-segment_stop)*sin(a) + dy*cos(a);\\n                    if( x > 0.0 ) discard;\\n                    // We transform the caps into square to avoid holes\\n                    dash_caps.y = 4.0;\\n                }\\n            }\\n        }\\n\\n        // Line cap at start\\n        if( (dx < line_start) && (dash_start < line_start) && (dash_stop > line_start) ) {\\n            d = cap( int(linecaps.x), dx-line_start, dy, t, v_linewidth);\\n        }\\n        // Line cap at stop\\n        else if( (dx > line_stop) && (dash_stop > line_stop) && (dash_start < line_stop) ) {\\n            d = cap( int(linecaps.y), dx-line_stop, dy, t, v_linewidth);\\n        }\\n        // Dash cap left - dash_type = -1, 0 or 1, but there may be roundoff errors\\n        else if( dash_type < -0.5 ) {\\n            d = cap( int(dash_caps.y), abs(u-dash_center), dy, t, v_linewidth);\\n            if( (dx > line_start) && (dx < line_stop) )\\n                d = max(d,d_join);\\n        }\\n        // Dash cap right\\n        else if( dash_type > 0.5 ) {\\n            d = cap( int(dash_caps.x), abs(dash_center-u), dy, t, v_linewidth);\\n            if( (dx > line_start) && (dx < line_stop) )\\n                d = max(d,d_join);\\n        }\\n        // Dash body (plain)\\n        else {// if( dash_type > -0.5 &&  dash_type < 0.5) {\\n            d = abs(dy);\\n        }\\n\\n        // Line join\\n        if( (dx > line_start) && (dx < line_stop)) {\\n            if( (dx <= segment_start) && (dash_start <= segment_start)\\n                && (dash_stop >= segment_start) ) {\\n                d = d_join;\\n                // Antialias at outer border\\n                float angle = PI/2.+v_angles.x;\\n                float f = abs( (segment_start - dx)*cos(angle) - dy*sin(angle));\\n                d = max(f,d);\\n            }\\n            else if( (dx > segment_stop) && (dash_start <= segment_stop)\\n                     && (dash_stop >= segment_stop) ) {\\n                d = d_join;\\n                // Antialias at outer border\\n                float angle = PI/2.+v_angles.y;\\n                float f = abs((dx - segment_stop)*cos(angle) - dy*sin(angle));\\n                d = max(f,d);\\n            }\\n            else if( dx < (segment_start - v_linewidth/2.)) {\\n                discard;\\n            }\\n            else if( dx > (segment_stop + v_linewidth/2.)) {\\n                discard;\\n            }\\n        }\\n        else if( dx < (segment_start - v_linewidth/2.)) {\\n            discard;\\n        }\\n        else if( dx > (segment_stop + v_linewidth/2.)) {\\n            discard;\\n        }\\n    }\\n\\n    // Distance to border ------------------------------------------------------\\n    d = d - t;\\n    if( d < 0.0 ) {\\n        gl_FragColor = color;\\n    } else {\\n        d /= u_antialias;\\n        gl_FragColor = vec4(color.rgb, exp(-d*d)*color.a);\\n    }\\n}';    \n}","/*models/glyphs/webgl/main*/\nfunction _(require, module, exports) {\n    require(425    /* ./index */);    \n}","/*models/glyphs/webgl/markers*/\nfunction _(require, module, exports) {\n    var tslib_1 = require(364    /* tslib */);\n    var MarkerGLGlyph;\n    var gloo2_1 = require(424    /* ./gloo2 */);\n    var base_1 = require(423    /* ./base */);\n    var logging_1 = require(14    /* core/logging */);\n    MarkerGLGlyph = function () {\n        var MarkerGLGlyph = function (_super) {\n            tslib_1.__extends(MarkerGLGlyph, _super);\n            function MarkerGLGlyph() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            MarkerGLGlyph.prototype.init = function () {\n                var frag, gl;\n                gl = this.gl;\n                frag = this.FRAG.replace(/MARKERCODE/, this.MARKERCODE);\n                this.last_trans = {};\n                // Keep track of transform\n                // The program\n                this.prog = new gloo2_1.Program(gl);\n                this.prog.set_shaders(this.VERT, frag);\n                // Real attributes\n                this.vbo_x = new gloo2_1.VertexBuffer(gl);\n                this.prog.set_attribute('a_x', 'float', this.vbo_x);\n                this.vbo_y = new gloo2_1.VertexBuffer(gl);\n                this.prog.set_attribute('a_y', 'float', this.vbo_y);\n                this.vbo_s = new gloo2_1.VertexBuffer(gl);\n                this.prog.set_attribute('a_size', 'float', this.vbo_s);\n                this.vbo_a = new gloo2_1.VertexBuffer(gl);\n                this.prog.set_attribute('a_angle', 'float', this.vbo_a);\n                // VBO's for attributes (they may not be used if value is singleton)\n                this.vbo_linewidth = new gloo2_1.VertexBuffer(gl);\n                this.vbo_fg_color = new gloo2_1.VertexBuffer(gl);\n                this.vbo_bg_color = new gloo2_1.VertexBuffer(gl);\n                return this.index_buffer = new gloo2_1.IndexBuffer(gl);\n            };\n            MarkerGLGlyph.prototype.draw = function (indices, mainGlyph, trans) {\n                var baked_offset, chunk, chunks, chunksize, i, j, k, l, mainGlGlyph, nvertices, offset, ref, ref1, ref2, results, s, these_indices, ua, uint16_index;\n                // The main glyph has the data, *this* glyph has the visuals.\n                mainGlGlyph = mainGlyph.glglyph;\n                nvertices = mainGlGlyph.nvertices;\n                // Upload data if we must. Only happens for main glyph.\n                if (mainGlGlyph.data_changed) {\n                    if (!(isFinite(trans.dx) && isFinite(trans.dy))) {\n                        return;\n                    }\n                    mainGlGlyph._baked_offset = [\n                        trans.dx,\n                        trans.dy\n                    ];\n                    mainGlGlyph._set_data(nvertices);\n                    mainGlGlyph.data_changed = false;\n                } else if (this.glyph._radius != null && (trans.sx !== this.last_trans.sx || trans.sy !== this.last_trans.sy)) {\n                    // Keep screen radius up-to-date for circle glyph. Only happens when a radius is given\n                    this.last_trans = trans;\n                    this.vbo_s.set_data(0, new Float32Array(function () {\n                        var j, len, ref, results;\n                        ref = this.glyph.sradius;\n                        results = [];\n                        for (j = 0, len = ref.length; j < len; j++) {\n                            s = ref[j];\n                            results.push(s * 2);\n                        }\n                        return results;\n                    }.call(this)));\n                }\n                // Update visuals if we must. Can happen for all glyphs.\n                if (this.visuals_changed) {\n                    this._set_visuals(nvertices);\n                    this.visuals_changed = false;\n                }\n                // Handle transformation to device coordinates\n                // Note the baked-in offset to avoid float32 precision problems\n                baked_offset = mainGlGlyph._baked_offset;\n                this.prog.set_uniform('u_pixel_ratio', 'float', [trans.pixel_ratio]);\n                this.prog.set_uniform('u_canvas_size', 'vec2', [\n                    trans.width,\n                    trans.height\n                ]);\n                this.prog.set_uniform('u_offset', 'vec2', [\n                    trans.dx - baked_offset[0],\n                    trans.dy - baked_offset[1]\n                ]);\n                this.prog.set_uniform('u_scale', 'vec2', [\n                    trans.sx,\n                    trans.sy\n                ]);\n                // Select buffers from main glyph\n                // (which may be this glyph but maybe not if this is a (non)selection glyph)\n                this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x);\n                this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y);\n                this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s);\n                this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a);\n                // Draw directly or using indices. Do not handle indices if they do not\n                // fit in a uint16; WebGL 1.0 does not support uint32.\n                if (indices.length === 0) {\n                } else if (indices.length === nvertices) {\n                    return this.prog.draw(this.gl.POINTS, [\n                        0,\n                        nvertices\n                    ]);\n                } else if (nvertices < 65535) {\n                    // On IE the marker size is reduced to 1 px when using an index buffer\n                    // A MS Edge dev on Twitter said on 24-04-2014: \"gl_PointSize > 1.0 works\n                    // in DrawArrays; gl_PointSize > 1.0 in DrawElements is coming soon in the\n                    // next renderer update.\n                    ua = window.navigator.userAgent;\n                    if (ua.indexOf('MSIE ') + ua.indexOf('Trident/') + ua.indexOf('Edge/') > 0) {\n                        logging_1.logger.warn('WebGL warning: IE is known to produce 1px sprites whith selections.');\n                    }\n                    this.index_buffer.set_size(indices.length * 2);\n                    this.index_buffer.set_data(0, new Uint16Array(indices));\n                    return this.prog.draw(this.gl.POINTS, this.index_buffer);\n                } else {\n                    // Work around the limit that the indexbuffer must be uint16. We draw in chunks.\n                    // First collect indices in chunks\n                    chunksize = 64000;\n                    // 65536\n                    chunks = [];\n                    for (i = j = 0, ref = Math.ceil(nvertices / chunksize); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                        chunks.push([]);\n                    }\n                    for (i = k = 0, ref1 = indices.length; 0 <= ref1 ? k < ref1 : k > ref1; i = 0 <= ref1 ? ++k : --k) {\n                        uint16_index = indices[i] % chunksize;\n                        chunk = Math.floor(indices[i] / chunksize);\n                        chunks[chunk].push(uint16_index);\n                    }\n                    results = [];\n                    // Then draw each chunk\n                    for (chunk = l = 0, ref2 = chunks.length; 0 <= ref2 ? l < ref2 : l > ref2; chunk = 0 <= ref2 ? ++l : --l) {\n                        these_indices = new Uint16Array(chunks[chunk]);\n                        offset = chunk * chunksize * 4;\n                        if (these_indices.length === 0) {\n                            continue;\n                        }\n                        this.prog.set_attribute('a_x', 'float', mainGlGlyph.vbo_x, 0, offset);\n                        this.prog.set_attribute('a_y', 'float', mainGlGlyph.vbo_y, 0, offset);\n                        this.prog.set_attribute('a_size', 'float', mainGlGlyph.vbo_s, 0, offset);\n                        this.prog.set_attribute('a_angle', 'float', mainGlGlyph.vbo_a, 0, offset);\n                        if (this.vbo_linewidth.used) {\n                            this.prog.set_attribute('a_linewidth', 'float', this.vbo_linewidth, 0, offset);\n                        }\n                        if (this.vbo_fg_color.used) {\n                            this.prog.set_attribute('a_fg_color', 'vec4', this.vbo_fg_color, 0, offset * 4);\n                        }\n                        if (this.vbo_bg_color.used) {\n                            this.prog.set_attribute('a_bg_color', 'vec4', this.vbo_bg_color, 0, offset * 4);\n                        }\n                        // The actual drawing\n                        this.index_buffer.set_size(these_indices.length * 2);\n                        this.index_buffer.set_data(0, these_indices);\n                        results.push(this.prog.draw(this.gl.POINTS, this.index_buffer));\n                    }\n                    return results;\n                }\n            };\n            MarkerGLGlyph.prototype._set_data = function (nvertices) {\n                var i, j, n, ref, s, xx, yy;\n                n = nvertices * 4;\n                // in bytes\n                // Set buffer size\n                this.vbo_x.set_size(n);\n                this.vbo_y.set_size(n);\n                this.vbo_a.set_size(n);\n                this.vbo_s.set_size(n);\n                // Upload data for x and y, apply a baked-in offset for float32 precision (issue #3795)\n                // The exact value for the baked_offset does not matter, as long as it brings the data to less extreme values\n                xx = new Float64Array(this.glyph._x);\n                yy = new Float64Array(this.glyph._y);\n                for (i = j = 0, ref = nvertices; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {\n                    xx[i] += this._baked_offset[0];\n                    yy[i] += this._baked_offset[1];\n                }\n                this.vbo_x.set_data(0, new Float32Array(xx));\n                this.vbo_y.set_data(0, new Float32Array(yy));\n                // Angle if available; circle does not have angle. If we don't set data, angle is default 0 in glsl\n                if (this.glyph._angle != null) {\n                    this.vbo_a.set_data(0, new Float32Array(this.glyph._angle));\n                }\n                // Radius is special; some markes allow radius in data-coords instead of screen coords\n                // @radius tells us that radius is in units, sradius is the pre-calculated screen radius\n                if (this.glyph._radius != null) {\n                    return this.vbo_s.set_data(0, new Float32Array(function () {\n                        var k, len, ref1, results;\n                        ref1 = this.glyph.sradius;\n                        results = [];\n                        for (k = 0, len = ref1.length; k < len; k++) {\n                            s = ref1[k];\n                            results.push(s * 2);\n                        }\n                        return results;\n                    }.call(this)));\n                } else {\n                    return this.vbo_s.set_data(0, new Float32Array(this.glyph._size));\n                }\n            };\n            MarkerGLGlyph.prototype._set_visuals = function (nvertices) {\n                base_1.attach_float(this.prog, this.vbo_linewidth, 'a_linewidth', nvertices, this.glyph.visuals.line, 'line_width');\n                base_1.attach_color(this.prog, this.vbo_fg_color, 'a_fg_color', nvertices, this.glyph.visuals.line, 'line');\n                base_1.attach_color(this.prog, this.vbo_bg_color, 'a_bg_color', nvertices, this.glyph.visuals.fill, 'fill');\n                // Static value for antialias. Smaller aa-region to obtain crisper images\n                return this.prog.set_uniform('u_antialias', 'float', [0.8]);\n            };\n            return MarkerGLGlyph;\n        }(base_1.BaseGLGlyph);\n        ;\n        // Base class for markers. All markers share the same GLSL, except for one\n        // function that defines the marker geometry.\n        MarkerGLGlyph.prototype.VERT = 'precision mediump float;\\nconst float SQRT_2 = 1.4142135623730951;\\n//\\nuniform float u_pixel_ratio;\\nuniform vec2 u_canvas_size;\\nuniform vec2 u_offset;\\nuniform vec2 u_scale;\\nuniform float u_antialias;\\n//\\nattribute float a_x;\\nattribute float a_y;\\nattribute float a_size;\\nattribute float a_angle;  // in radians\\nattribute float a_linewidth;\\nattribute vec4  a_fg_color;\\nattribute vec4  a_bg_color;\\n//\\nvarying float v_linewidth;\\nvarying float v_size;\\nvarying vec4  v_fg_color;\\nvarying vec4  v_bg_color;\\nvarying vec2  v_rotation;\\n\\nvoid main (void)\\n{\\n    v_size = a_size * u_pixel_ratio;\\n    v_linewidth = a_linewidth * u_pixel_ratio;\\n    v_fg_color = a_fg_color;\\n    v_bg_color = a_bg_color;\\n    v_rotation = vec2(cos(-a_angle), sin(-a_angle));\\n    // Calculate position - the -0.5 is to correct for canvas origin\\n    vec2 pos = (vec2(a_x, a_y) + u_offset) * u_scale; // in pixels\\n    pos += 0.5;  // make up for Bokeh\\'s offset\\n    pos /= u_canvas_size / u_pixel_ratio;  // in 0..1\\n    gl_Position = vec4(pos*2.0-1.0, 0.0, 1.0);\\n    gl_Position.y *= -1.0;\\n    gl_PointSize = SQRT_2 * v_size + 2.0 * (v_linewidth + 1.5*u_antialias);\\n}';\n        MarkerGLGlyph.prototype.FRAG = 'precision mediump float;\\nconst float SQRT_2 = 1.4142135623730951;\\nconst float PI = 3.14159265358979323846264;\\n//\\nuniform float u_antialias;\\n//\\nvarying vec4  v_fg_color;\\nvarying vec4  v_bg_color;\\nvarying float v_linewidth;\\nvarying float v_size;\\nvarying vec2  v_rotation;\\n\\nMARKERCODE\\n\\nvec4 outline(float distance, float linewidth, float antialias, vec4 fg_color, vec4 bg_color)\\n{\\n    vec4 frag_color;\\n    float t = linewidth/2.0 - antialias;\\n    float signed_distance = distance;\\n    float border_distance = abs(signed_distance) - t;\\n    float alpha = border_distance/antialias;\\n    alpha = exp(-alpha*alpha);\\n\\n    // If fg alpha is zero, it probably means no outline. To avoid a dark outline\\n    // shining through due to aa, we set the fg color to the bg color. Avoid if (i.e. branching).\\n    float select = float(bool(fg_color.a));\\n    fg_color.rgb = select * fg_color.rgb + (1.0  - select) * bg_color.rgb;\\n    // Similarly, if we want a transparent bg\\n    select = float(bool(bg_color.a));\\n    bg_color.rgb = select * bg_color.rgb + (1.0  - select) * fg_color.rgb;\\n\\n    if( border_distance < 0.0)\\n        frag_color = fg_color;\\n    else if( signed_distance < 0.0 ) {\\n        frag_color = mix(bg_color, fg_color, sqrt(alpha));\\n    } else {\\n        if( abs(signed_distance) < (linewidth/2.0 + antialias) ) {\\n            frag_color = vec4(fg_color.rgb, fg_color.a * alpha);\\n        } else {\\n            discard;\\n        }\\n    }\\n    return frag_color;\\n}\\n\\nvoid main()\\n{\\n    vec2 P = gl_PointCoord.xy - vec2(0.5, 0.5);\\n    P = vec2(v_rotation.x*P.x - v_rotation.y*P.y,\\n             v_rotation.y*P.x + v_rotation.x*P.y);\\n    float point_size = SQRT_2*v_size  + 2.0 * (v_linewidth + 1.5*u_antialias);\\n    float distance = marker(P*point_size, v_size);\\n    gl_FragColor = outline(distance, v_linewidth, u_antialias, v_fg_color, v_bg_color);\\n    //gl_FragColor.rgb *= gl_FragColor.a;  // pre-multiply alpha\\n}';\n        MarkerGLGlyph.prototype.MARKERCODE = '<defined in subclasses>';\n        return MarkerGLGlyph;\n    }();\n    var CircleGLGlyph = function (_super) {\n        tslib_1.__extends(CircleGLGlyph, _super);\n        function CircleGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return CircleGLGlyph;\n    }(MarkerGLGlyph);\n    exports.CircleGLGlyph = CircleGLGlyph;\n    ;\n    CircleGLGlyph.prototype.GLYPH = 'circle';\n    CircleGLGlyph.prototype.MARKERCODE = '// --- disc\\nfloat marker(vec2 P, float size)\\n{\\n    return length(P) - size/2.0;\\n}';\n    var SquareGLGlyph = function (_super) {\n        tslib_1.__extends(SquareGLGlyph, _super);\n        function SquareGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return SquareGLGlyph;\n    }(MarkerGLGlyph);\n    exports.SquareGLGlyph = SquareGLGlyph;\n    ;\n    SquareGLGlyph.prototype.GLYPH = 'square';\n    SquareGLGlyph.prototype.MARKERCODE = '// --- square\\nfloat marker(vec2 P, float size)\\n{\\n    return max(abs(P.x), abs(P.y)) - size/2.0;\\n}';\n    var AnnulusGLGlyph = function (_super) {\n        tslib_1.__extends(AnnulusGLGlyph, _super);\n        function AnnulusGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return AnnulusGLGlyph;\n    }(MarkerGLGlyph);\n    exports.AnnulusGLGlyph = AnnulusGLGlyph;\n    ;\n    AnnulusGLGlyph.prototype.GLYPH = 'annulus';\n    AnnulusGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float r1 = length(P) - size/2.0;\\n    float r2 = length(P) - size/4.0;  // half width\\n    return max(r1, -r2);\\n}';\n    var DiamondGLGlyph = function (_super) {\n        tslib_1.__extends(DiamondGLGlyph, _super);\n        function DiamondGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return DiamondGLGlyph;\n    }(MarkerGLGlyph);\n    exports.DiamondGLGlyph = DiamondGLGlyph;\n    ;\n    DiamondGLGlyph.prototype.GLYPH = 'diamond';\n    DiamondGLGlyph.prototype.MARKERCODE = '// --- diamond\\nfloat marker(vec2 P, float size)\\n{\\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\\n    return r1 / SQRT_2;\\n}';\n    var TriangleGLGlyph = function (_super) {\n        tslib_1.__extends(TriangleGLGlyph, _super);\n        function TriangleGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return TriangleGLGlyph;\n    }(MarkerGLGlyph);\n    exports.TriangleGLGlyph = TriangleGLGlyph;\n    ;\n    TriangleGLGlyph.prototype.GLYPH = 'triangle';\n    TriangleGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    P.y -= size * 0.3;\\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\\n    float r2 = P.y;\\n    return max(r1 / SQRT_2, r2);  // Instersect diamond with rectangle\\n}';\n    var InvertedTriangleGLGlyph = function (_super) {\n        tslib_1.__extends(InvertedTriangleGLGlyph, _super);\n        function InvertedTriangleGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return InvertedTriangleGLGlyph;\n    }(MarkerGLGlyph);\n    exports.InvertedTriangleGLGlyph = InvertedTriangleGLGlyph;\n    ;\n    InvertedTriangleGLGlyph.prototype.GLYPH = 'invertedtriangle';\n    InvertedTriangleGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    P.y += size * 0.3;\\n    float x = SQRT_2 / 2.0 * (P.x * 1.7 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.7 + P.y);\\n    float r1 = max(abs(x), abs(y)) - size / 1.6;\\n    float r2 = - P.y;\\n    return max(r1 / SQRT_2, r2);  // Instersect diamond with rectangle\\n}';\n    var CrossGLGlyph = function (_super) {\n        tslib_1.__extends(CrossGLGlyph, _super);\n        function CrossGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return CrossGLGlyph;\n    }(MarkerGLGlyph);\n    exports.CrossGLGlyph = CrossGLGlyph;\n    ;\n    CrossGLGlyph.prototype.GLYPH = 'cross';\n    CrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float square = max(abs(P.x), abs(P.y)) - size / 2.5;  // 2.5 is a tweak\\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    return max(square, cross);\\n}';\n    var CircleCrossGLGlyph = function (_super) {\n        tslib_1.__extends(CircleCrossGLGlyph, _super);\n        function CircleCrossGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return CircleCrossGLGlyph;\n    }(MarkerGLGlyph);\n    exports.CircleCrossGLGlyph = CircleCrossGLGlyph;\n    ;\n    CircleCrossGLGlyph.prototype.GLYPH = 'circlecross';\n    CircleCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float circle = length(P) - size/2.0;\\n    float c1 = max(circle, s1);\\n    float c2 = max(circle, s2);\\n    float c3 = max(circle, s3);\\n    float c4 = max(circle, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\n    var SquareCrossGLGlyph = function (_super) {\n        tslib_1.__extends(SquareCrossGLGlyph, _super);\n        function SquareCrossGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return SquareCrossGLGlyph;\n    }(MarkerGLGlyph);\n    exports.SquareCrossGLGlyph = SquareCrossGLGlyph;\n    ;\n    SquareCrossGLGlyph.prototype.GLYPH = 'squarecross';\n    SquareCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\\n    float c1 = max(square, s1);\\n    float c2 = max(square, s2);\\n    float c3 = max(square, s3);\\n    float c4 = max(square, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\n    var DiamondCrossGLGlyph = function (_super) {\n        tslib_1.__extends(DiamondCrossGLGlyph, _super);\n        function DiamondCrossGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return DiamondCrossGLGlyph;\n    }(MarkerGLGlyph);\n    exports.DiamondCrossGLGlyph = DiamondCrossGLGlyph;\n    ;\n    DiamondCrossGLGlyph.prototype.GLYPH = 'diamondcross';\n    DiamondCrossGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(P.x - qs), abs(P.y - qs)) - qs;\\n    float s2 = max(abs(P.x + qs), abs(P.y - qs)) - qs;\\n    float s3 = max(abs(P.x - qs), abs(P.y + qs)) - qs;\\n    float s4 = max(abs(P.x + qs), abs(P.y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float x = SQRT_2 / 2.0 * (P.x * 1.5 - P.y);\\n    float y = SQRT_2 / 2.0 * (P.x * 1.5 + P.y);\\n    float diamond = max(abs(x), abs(y)) - size / (2.0 * SQRT_2);\\n    diamond /= SQRT_2;\\n    float c1 = max(diamond, s1);\\n    float c2 = max(diamond, s2);\\n    float c3 = max(diamond, s3);\\n    float c4 = max(diamond, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\n    var XGLGlyph = function (_super) {\n        tslib_1.__extends(XGLGlyph, _super);\n        function XGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return XGLGlyph;\n    }(MarkerGLGlyph);\n    exports.XGLGlyph = XGLGlyph;\n    ;\n    XGLGlyph.prototype.GLYPH = 'x';\n    XGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float circle = length(P) - size / 1.6;\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    return max(circle, X);\\n}';\n    var CircleXGLGlyph = function (_super) {\n        tslib_1.__extends(CircleXGLGlyph, _super);\n        function CircleXGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return CircleXGLGlyph;\n    }(MarkerGLGlyph);\n    exports.CircleXGLGlyph = CircleXGLGlyph;\n    ;\n    CircleXGLGlyph.prototype.GLYPH = 'circlex';\n    CircleXGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float x = P.x - P.y;\\n    float y = P.x + P.y;\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float circle = length(P) - size/2.0;\\n    float c1 = max(circle, s1);\\n    float c2 = max(circle, s2);\\n    float c3 = max(circle, s3);\\n    float c4 = max(circle, s4);\\n    // Union\\n    float almost = min(min(min(c1, c2), c3), c4);\\n    // In this case, the X is also outside of the main shape\\n    float Xmask = length(P) - size / 1.6;  // a circle\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    return min(max(X, Xmask), almost);\\n}';\n    var SquareXGLGlyph = function (_super) {\n        tslib_1.__extends(SquareXGLGlyph, _super);\n        function SquareXGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return SquareXGLGlyph;\n    }(MarkerGLGlyph);\n    exports.SquareXGLGlyph = SquareXGLGlyph;\n    ;\n    SquareXGLGlyph.prototype.GLYPH = 'squarex';\n    SquareXGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    float x = P.x - P.y;\\n    float y = P.x + P.y;\\n    // Define quadrants\\n    float qs = size / 2.0;  // quadrant size\\n    float s1 = max(abs(x - qs), abs(y - qs)) - qs;\\n    float s2 = max(abs(x + qs), abs(y - qs)) - qs;\\n    float s3 = max(abs(x - qs), abs(y + qs)) - qs;\\n    float s4 = max(abs(x + qs), abs(y + qs)) - qs;\\n    // Intersect main shape with quadrants (to form cross)\\n    float square = max(abs(P.x), abs(P.y)) - size/2.0;\\n    float c1 = max(square, s1);\\n    float c2 = max(square, s2);\\n    float c3 = max(square, s3);\\n    float c4 = max(square, s4);\\n    // Union\\n    return min(min(min(c1, c2), c3), c4);\\n}';\n    var AsteriskGLGlyph = function (_super) {\n        tslib_1.__extends(AsteriskGLGlyph, _super);\n        function AsteriskGLGlyph() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return AsteriskGLGlyph;\n    }(MarkerGLGlyph);\n    exports.AsteriskGLGlyph = AsteriskGLGlyph;\n    ;\n    AsteriskGLGlyph.prototype.GLYPH = 'asterisk';\n    AsteriskGLGlyph.prototype.MARKERCODE = 'float marker(vec2 P, float size)\\n{\\n    // Masks\\n    float diamond = max(abs(SQRT_2 / 2.0 * (P.x - P.y)), abs(SQRT_2 / 2.0 * (P.x + P.y))) - size / (2.0 * SQRT_2);\\n    float square = max(abs(P.x), abs(P.y)) - size / (2.0 * SQRT_2);\\n    // Shapes\\n    float X = min(abs(P.x - P.y), abs(P.x + P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    float cross = min(abs(P.x), abs(P.y)) - size / 100.0;  // bit of \"width\" for aa\\n    // Result is union of masked shapes\\n    return min(max(X, diamond), max(cross, square));\\n}';    \n}"]}